---
title: "Analyzing RNA-seq data with DESeq2"
author: "Michael I. Love, Simon Anders, and Wolfgang Huber"
date: "`r format(Sys.Date(), '%m/%d/%Y')`"
abstract: >
  A basic task in the analysis of count data from RNA-seq is the
  detection of differentially expressed genes. The count data are
  presented as a table which reports, for each sample, the number of
  sequence fragments that have been assigned to each gene. Analogous
  data also arise for other assay types, including comparative ChIP-Seq,
  HiC, shRNA screening, mass spectrometry.  An important analysis
  question is the quantification and statistical inference of systematic
  changes between conditions, as compared to within-condition
  variability. The package DESeq2 provides methods to test for
  differential expression by use of negative binomial generalized linear
  models; the estimates of dispersion and logarithmic fold changes
  incorporate data-driven prior distributions This vignette explains the
  use of the package and demonstrates typical workflows.
  on the Bioconductor website covers similar material to this vignette
  but at a slower pace, including the generation of count matrices from
  FASTQ files.
  [An RNA-seq workflow](http://www.bioconductor.org/help/workflows/rnaseqGene/)
  DESeq2 package version: `r packageVersion("DESeq2")`
output:
  rmarkdown::html_document:
    highlight: pygments
    toc: true
    fig_width: 5
bibliography: library.bib
vignette: >
  %\VignetteIndexEntry{Analyzing RNA-seq data with DESeq2}
  %\VignetteEncoding{UTF-8}
  %\usepackage[utf8]{inputenc}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: inline
---

```{r setup, echo=FALSE, results="hide"}
library(knitr)
knitr::opts_chunk$set(tidy=FALSE, cache=TRUE,
                      dev="png",
                      message=FALSE, error=FALSE, warning=TRUE)
#source("https://bioconductor.org/biocLite.R")
#        biocLite("apeglm")
library(apeglm)
#source("https://bioconductor.org/biocLite.R")
 #       biocLite("parathyroidSE")
#library("parathyroidSE")
  #      source("https://bioconductor.org/biocLite.R")
   #     biocLite("DESeq2")
library(DESeq2)
```	

# Standard workflow

**Note:** if you use DESeq2 in published research, please cite:

> Love, M.I., Huber, W., Anders, S. (2014)
> Moderated estimation of fold change and dispersion for RNA-seq data with DESeq2.
> *Genome Biology*, **15**:550.
> [10.1186/s13059-014-0550-8](http://dx.doi.org/10.1186/s13059-014-0550-8)

Other Bioconductor packages with similar aims are
[edgeR](http://bioconductor.org/packages/edgeR),
[limma](http://bioconductor.org/packages/limma),
[DSS](http://bioconductor.org/packages/DSS),
[EBSeq](http://bioconductor.org/packages/EBSeq), and 
[baySeq](http://bioconductor.org/packages/baySeq).

## Quick start

Here we show the most basic steps for a differential expression
analysis. There are a variety of steps upstream of DESeq2 that result
in the generation of counts or estimated counts for each sample, which
we will discuss in the sections below. This code chunk assumes that
you have a count matrix called `cts` and a table of sample
information called `coldata`.  The `design` indicates how to model the
samples, here, that we want to measure the effect of the condition,
controlling for batch differences. The two factor variables `batch`
and `condition` should  be columns of `coldata`. 

```{r quickStart, eval=FALSE}
data("parathyroidGenesSE")
se <- parathyroidGenesSE
cts <- assay(parathyroidGenesSE)

coldata <- colData(parathyroidGenesSE)
head(coldata)




dds <- DESeqDataSetFromMatrix(countData = cts,
                              colData = coldata,
                              design= ~ patient + treatment)
dds <- DESeq(dds)
resultsNames(dds) # lists the coefficients
res <- results(dds, name="treatment_DPN_vs_Control")
# or to shrink log fold changes association with condition:
resLFC <- lfcShrink(dds, coef="treatment_DPN_vs_Control", type="apeglm")
```

The following starting functions will be explained below:

* If you have transcript quantification files, as produced by
  *Salmon*, *Sailfish*, or *kallisto*, you would use
  *DESeqDataSetFromTximport*.
* If you have *htseq-count* files, the first line would use
  *DESeqDataSetFromHTSeq*.
* If you have a *RangedSummarizedExperiment*, the first line would use 
  *DESeqDataSet*.

## How to get help for DESeq2

Any and all DESeq2 questions should be posted to the 
**Bioconductor support site**, which serves as a searchable knowledge
base of questions and answers:

<https://support.bioconductor.org>

Posting a question and tagging with "DESeq2" will automatically send
an alert to the package authors to respond on the support site.  See
the first question in the list of [Frequently Asked Questions](#FAQ)
(FAQ) for information about how to construct an informative post. 

You should **not** email your question to the package authors, as we will
just reply that the question should be posted to the 
**Bioconductor support site**.

## Input data

### Why un-normalized counts?

As input, the DESeq2 package expects count data as obtained, e.g.,
from RNA-seq or another high-throughput sequencing experiment, in the form of a
matrix of integer values. The value in the *i*-th row and the *j*-th column of
the matrix tells how many reads can be assigned to gene *i* in sample *j*.
Analogously, for other types of assays, the rows of the matrix might correspond
e.g. to binding regions (with ChIP-Seq) or peptide sequences (with
quantitative mass spectrometry). We will list method for obtaining count matrices
in sections below.

The values in the matrix should be un-normalized counts or estimated
counts of sequencing reads (for
single-end RNA-seq) or fragments (for paired-end RNA-seq). 
The [RNA-seq workflow](http://www.bioconductor.org/help/workflows/rnaseqGene/)
describes multiple techniques for preparing such count matrices.  It
is important to provide count matrices as input for DESeq2's
statistical model [@Love2014] to hold, as only the count values allow
assessing the measurement precision correctly. The DESeq2 model
internally corrects for library size, so transformed or normalized
values such as counts scaled by library size should not be used as
input.

### The DESeqDataSet

The object class used by the DESeq2 package to store the read counts 
and the intermediate estimated quantities during statistical analysis
is the *DESeqDataSet*, which will usually be represented in the code
here as an object `dds`.

A technical detail is that the *DESeqDataSet* class extends the
*RangedSummarizedExperiment* class of the 
[SummarizedExperiment](http://bioconductor.org/packages/SummarizedExperiment) package. 
The "Ranged" part refers to the fact that the rows of the assay data 
(here, the counts) can be associated with genomic ranges (the exons of genes).
This association facilitates downstream exploration of results, making use of
other Bioconductor packages' range-based functionality
(e.g. find the closest ChIP-seq peaks to the differentially expressed genes).

A *DESeqDataSet* object must have an associated *design formula*.
The design formula expresses the variables which will be
used in modeling. The formula should be a tilde (~) followed by the
variables with plus signs between them (it will be coerced into an
*formula* if it is not already). The design can be changed later, 
however then all differential analysis steps should be repeated, 
as the design formula is used to estimate the dispersions and 
to estimate the log2 fold changes of the model. 

*Note*: In order to benefit from the default settings of the
package, you should put the variable of interest at the end of the
formula and make sure the control level is the first level.

We will now show 4 ways of constructing a *DESeqDataSet*, depending
on what pipeline was used upstream of DESeq2 to generated counts or
estimated counts:

1) From [transcript abundance files and tximport](#tximport)
2) From a [count matrix](#countmat)
3) From [htseq-count files](#htseq)
4) From a [SummarizedExperiment](#se) object


### Count matrix input

Alternatively, the function *DESeqDataSetFromMatrix* can be
used if you already have a matrix of read counts prepared from another
source. Another method for quickly producing count matrices 
from alignment files is the *featureCounts* function [@Liao2013feature]
in the [Rsubread](http://bioconductor.org/packages/Rsubread) package.
To use *DESeqDataSetFromMatrix*, the user should provide 
the counts matrix, the information about the samples (the columns of the 
count matrix) as a *DataFrame* or *data.frame*, and the design formula.

To demonstate the use of *DESeqDataSetFromMatrix*, 
we will read in count data from the
[pasilla](http://bioconductor.org/packages/pasilla) package. 
We read in a count matrix, which we will name `cts`, 
and the sample information table, which we will name `coldata`. 
Further below we describe how to extract these objects from,
e.g. *featureCounts* output. 

<a name="htseq"/>

### *htseq-count* input

You can use the function *DESeqDataSetFromHTSeqCount* if you
have used *htseq-count* from the 
[HTSeq](http://www-huber.embl.de/users/anders/HTSeq) 
python package [@Anders:2014:htseq].
For an example of using the python scripts, see the
[pasilla](http://bioconductor.org/packages/pasilla) data package. First you will want to specify a
variable which points to the directory in which the *htseq-count*
output files are located. 

```{r htseqDirI, eval=FALSE}
directory <- "/Users/hollymcqueary/Dropbox/McQueary/Dosage-Compensation/Indiv_Genes/HTseq/HTseq_update_May2018/GC/exons_unstranded"

```

We specify which files to read in using *list.files*,
and select those files which contain the string `"treated"`
using *grep*. The *sub* function is used to 
chop up the sample filename to obtain the condition status, or 
you might alternatively read in a phenotypic table 
using *read.table*.

```{r htseqInput}
sampleFiles <- list.files(directory)
sampleInfo <- read.csv("/Users/hollymcqueary/Dropbox/McQueary/Dosage-Compensation/Paper_Drafts/sample_data_shrt.csv",header=TRUE)
sampleTable <- data.frame(sampleName = sampleInfo$sample,
                          fileName = sampleInfo$filename,
                          run = sampleInfo$seq_run,
                          condition = sampleInfo$group)


```



Then we build the *DESeqDataSet* using the following function:

```{r hsteqDds}
#library("DESeq2")
sampleTable$run <- as.factor(sampleTable$run)
sampleTable$sampleName <- as.factor(sampleTable$sampleName)
sampleTable$condition <- as.factor(sampleTable$condition)
ddsHTSeq <- DESeqDataSetFromHTSeqCount(sampleTable = sampleTable,
                                       directory = directory,
                                       design= ~ condition + run)

ddsHTSeq

write.csv(counts(ddsHTSeq),file="counts.DEseq.csv")

```
### Note on factor levels 

By default, R will choose a *reference level* for factors based on
alphabetical order. Then, if you never tell the DESeq2 functions which
level you want to compare against (e.g. which level represents the
control group), the comparisons will be based on the alphabetical
order of the levels. There are two solutions: you can either
explicitly tell *results* which comparison to make using the
`contrast` argument (this will be shown later), or you can explicitly
set the factors levels. You should only change the factor levels
of variables in the design before running the DESeq2 analysis, not
during or afterward.

```{r relevel}
ddsHTSeq$condition <- relevel(ddsHTSeq$condition, ref = "Holly_Anc")

``` 


### Pre-filtering

While it is not necessary to pre-filter low count genes before running
the DESeq2 functions, there are two reasons which make pre-filtering
useful: by removing rows in which there are very few reads, we reduce
the memory size of the `dds` data object, and we increase the speed of
the transformation and testing functions within DESeq2. Here we
perform a minimal pre-filtering to keep only rows that have at least
10 reads total. Note that more strict filtering to increase power is
*automatically* applied via [independent filtering](#indfilt) on the
mean of normalized counts within the *results* function.

```{r prefilter}
keep <- rowSums(counts(ddsHTSeq)) >= 20
ddsHTSeq <- ddsHTSeq[keep,]
ddsHTSeq

```

<a name="factorlevels"/>

## Differential expression analysis 

The standard differential expression analysis steps are wrapped
into a single function, *DESeq*. The estimation steps performed
by this function are described [below](#theory), in the manual page for
`?DESeq` and in the Methods section of the DESeq2 publication [@Love2014]. 

Results tables are generated using the function *results*, which
extracts a results table with log2 fold changes, *p* values and adjusted
*p* values. With no additional arguments to *results*, the log2 fold change and
Wald test *p* value will be for the **last variable** in the design
formula, and if this is a factor, the comparison will be the **last
level** of this variable over the **reference level** 
(see previous [note on factor levels](#factorlevels)). 
However, the order of the variables of the design do not matter
so long as the user specifies the comparison to build a results table
for, using the `name` or `contrast` arguments of *results*.

Details about the comparison are printed to the console, directly above the
results table. The text, `condition treated vs untreated`, tells you that the
estimates are of the logarithmic fold change log2(treated/untreated).

```{r sva}
#source("https://bioconductor.org/biocLite.R")
#biocLite("rnaseqGene")
library(rnaseqGene)
#browseVignettes(rnaseqGene)
source("https://bioconductor.org/biocLite.R")
biocLite("RUVSeq")
library(sva)
dds <- DESeq(ddsHTSeq)

data <- counts(dds,normalized=TRUE)
idx <- rowMeans(data) > 1 
data <- data[idx,]
mod <- model.matrix(~condition, colData(dds))
mod0 <- model.matrix(~1, colData(dds))
svseq <- svaseq(data,mod,mod0,n.sv = 2 )
svseq$sv

#see how good sva was at recovering the condition (sample group) variable:
par(mfrow=c(2,1), mar=c(3,5,3,1))
for (i in 1:2) {
  stripchart(svseq$sv[,i] ~dds$condition, vertical=TRUE, main= paste0("SV",i))
  abline(h=0)
}

#add surrogate variables to the design 
ddssva <- dds
ddssva$SV1 <- svseq$sv[,1]
ddssva$SV2 <- svseq$sv[,2]
design(ddssva) <- ~ SV1 + SV2 + condition
ddsSva <- DESeq(ddssva)

#testing on lines that work fine 
#2
resSV2 <- results(ddsSva, contrast=c("condition","Holly_2","Holly_Anc"))
summary(resSV2)
hist(resSV2$pvalue,col="green", main="2 vs Anc, with aneuploid c'somes", xlab="p values")

#lines that dont work fine 
#7 
resSV7 <- results(ddsSva, contrast=c("condition","Holly_7","Holly_Anc"))
summary(resSV7)
hist(resSV7$pvalue,col="green", main="7 vs Anc, with aneuploid c'somes", xlab="p values")



```

```{r full dataset, include=TRUE}
#####################################################
#default 
geneID <- rownames(ddsHTSeq)
library(TxDb.Scerevisiae.UCSC.sacCer2.sgdGene)
txdb <- TxDb.Scerevisiae.UCSC.sacCer2.sgdGene 
genes <- ensembldb::select(txdb, keys=geneID, columnns="GENEID","TXCHROM" , keytype="GENEID")
#remove the chromosomes that I don't want (i.e. anything that is NA for TXCHROM)
genes <- na.omit(genes)
genes <- as.data.frame(genes)
remove1 <- "chrM"
genes <- genes[-(grep(paste0(remove1,"$"),genes$TXCHROM,perl=TRUE)),]
all(rownames(ddsHTSeq) == genes$GENEID)
#need to remove the ones in rownames of dds that don't match genes$GENEID
matchedS1 <- intersect(rownames(ddsHTSeq), genes$GENEID)
keep3 <- rownames(ddsHTSeq) %in% matchedS1
ddsHTSeq <- ddsHTSeq[keep3,]
length(ddsHTSeq)
all(rownames(ddsHTSeq) == genes$GENEID)
mcols(ddsHTSeq) <- cbind(mcols(ddsHTSeq), genes)
ddsDef <- DESeq(ddsHTSeq)
attr(dispersionFunction(ddsDef),"dispPriorVar")
norm.factors.with.aneu <- as.data.frame(sizeFactors(ddsDef))
dispersions.with.aneu <- dispersions(ddsDef)

#aneuploid chromosomes removed
allGenes <- as.data.frame(mcols(ddsHTSeq))
View(allGenes)
ddsNoAneuInNorm <- estimateSizeFactors(ddsHTSeq, controlGenes=c(106:537,538:701,702:1498,1796:1924,3382:3717,4239:4723))
geneID <- rownames(ddsNoAneuInNorm)
#library(TxDb.Scerevisiae.UCSC.sacCer2.sgdGene)
txdb <- TxDb.Scerevisiae.UCSC.sacCer2.sgdGene 
genesNoAneu <- ensembldb::select(txdb, keys=geneID, columnns="GENEID","TXCHROM" , keytype="GENEID")
#remove the chromosomes that I don't want (i.e. anything that is NA for TXCHROM)
genesNoAneu <- na.omit(genesNoAneu)
genesNoAneu <- as.data.frame(genesNoAneu)
# remove1 <- "chrM"
# genesNoAneu <- genesNoAneu[-(grep(paste0(remove1,"$"),genesNoAneu$TXCHROM,perl=TRUE)),]
ddsNoAneuInNorm <- estimateDispersions(ddsNoAneuInNorm)
attr(dispersionFunction(ddsNoAneuInNorm),"dispPriorVar")
ddsNoAneuInNorm <- nbinomWaldTest(ddsNoAneuInNorm,useT=TRUE,df=(nrow(ddsNoAneuInNorm)))
norm.factors.no.aneu <- as.data.frame(sizeFactors(ddsNoAneuInNorm))
design(ddsNoAneuInNorm)
dispersions.no.aneu <- dispersions(ddsNoAneuInNorm)
#add annotation to DESeq2 data set
all(rownames(ddsNoAneuInNorm) == genesNoAneu$GENEID)
#need to remove the ones in rownames of dds that don't match genes$GENEID
#matchedNoAneu <- intersect(rownames(ddsNoAneuInNorm), genesNoAneu$GENEID)
#keep3 <- rownames(ddsNoAneuInNorm) %in% matchedNoAneu
#ddsNoAneuInNorm <- ddsNoAneuInNorm[keep3,]
#length(ddsNoAneuInNorm)
#all(rownames(ddsNoAneuInNorm) == genesNoAneu$GENEID)
#mcols(ddsNoAneuInNorm)
#then check again
all(rownames(ddsNoAneuInNorm) == genesNoAneu$GENEID)
#nrow(ddsNoAneuInNorm)
#nrow(genesNoAneu)
#mcols(ddsNoAneuInNorm) <- cbind(mcols(ddsNoAneuInNorm), genesNoAneu)
#mcols(ddsNoAneuInNorm)
#write.csv(counts(dds), file="counts.Rsubread.csv")
#mcols(dds)
write.csv(genes,file="gene_anno.csv")
write.csv(counts(ddsHTSeq),file="counts.filtered.csv")

``` 

Note that we could have specified the coefficient or contrast we want
to build a results table for, using either of the following equivalent
commands:

```{r results, eval=TRUE}
###########################################
#without aneuploid chromosomes
res <- results(ddsNoAneuInNorm)
res
resultsNames(ddsNoAneuInNorm)
#euploid line
res2 <- results(ddsNoAneuInNorm, contrast=c("condition","Holly_2","Holly_Anc"))
summary(res2)
sigGenes2 <- rownames(subset(res2,padj<0.1))
#aneuploid line 
resultsNames(ddsNoAneuInNorm)
res7 <- results(ddsNoAneuInNorm, contrast=c("condition","Holly_7","Holly_Anc"))#,cooksCutoff=FALSE)
summary(res7)
sigGenes7 <- rownames(subset(res7,padj<0.1))
res18 <- results(ddsNoAneuInNorm, contrast=c("condition","Holly_18","Holly_Anc"))#, cooksCutoff = FALSE)
summary(res18)
sigGenes18 <- rownames(subset(res18,padj<0.1))
res11 <- results(ddsNoAneuInNorm, contrast=c("condition","Holly_11","Holly_Anc"))#, cooksCutoff = FALSE)
summary(res11)
sigGenes11 <- rownames(subset(res11,padj<0.1))
res1 <- results(ddsNoAneuInNorm, contrast=c("condition","Holly_1","Holly_Anc"))#, cooksCutoff = FALSE)
summary(res1)
sigGenes1 <- rownames(subset(res1,padj<0.1))
res3 <- results(ddsNoAneuInNorm, contrast=c("condition","Holly_3","Holly_Anc"))#, cooksCutoff = FALSE)
summary(res3)
sigGenes3 <- rownames(subset(res3,padj<0.1))
res4 <- results(ddsNoAneuInNorm, contrast=c("condition","Holly_4","Holly_Anc"))#, cooksCutoff = FALSE)
summary(res4)
sigGenes4 <- rownames(subset(res4,padj<0.1))
res49 <- results(ddsNoAneuInNorm, contrast=c("condition","Holly_49","Holly_Anc"))#, cooksCutoff = FALSE)
summary(res49)
sigGenes49 <- rownames(subset(res49,padj<0.1))
res59 <- results(ddsNoAneuInNorm, contrast=c("condition","Holly_59","Holly_Anc"))#, cooksCutoff = FALSE)
summary(res59)
sigGenes59 <- rownames(subset(res59,padj<0.1))
res61 <- results(ddsNoAneuInNorm, contrast=c("condition","Holly_61","Holly_Anc"))#, cooksCutoff = FALSE)
summary(res61)
sigGenes61 <- rownames(subset(res61,padj<0.1))
res8 <- results(ddsNoAneuInNorm, contrast=c("condition","Holly_8","Holly_Anc"))#, cooksCutoff = FALSE)
summary(res8)
sigGenes8 <- rownames(subset(res8,padj<0.1))
res9 <- results(ddsNoAneuInNorm, contrast=c("condition","Holly_9","Holly_Anc"))#, cooksCutoff = FALSE)
summary(res9)
sigGenes9 <- rownames(subset(res9,padj<0.1))
#res69 <- results(ddsNoAneuInNorm, contrast=c("condition","Holly_69","Holly_Anc"))#, cooksCutoff = FALSE)
#summary(res69)
res76 <- results(ddsNoAneuInNorm, contrast=c("condition","Holly_76","Holly_Anc"))#, cooksCutoff = FALSE)
summary(res76)
sigGenes76 <- rownames(subset(res76,padj<0.1))
res77 <- results(ddsNoAneuInNorm, contrast=c("condition","Holly_77","Holly_Anc"))#, cooksCutoff = FALSE)
summary(res77)
sigGenes77 <- rownames(subset(res77,padj<0.1))




res5 <- results(ddsNoAneuInNorm, contrast=c("condition","Holly_5","Holly_Anc"))#, cooksCutoff = FALSE)
summary(res5)
sigGenes5 <- rownames(subset(res5,padj<0.1))





```

```{r common sig genes, include=TRUE}
## Big Problem: How many genes are differentially expressed in ALL samples?
# need to get results from DESeq into a more easily workable format (ie data frame)
  # make results from DESeq a data frame to work with
  res1Dat <- as.data.frame(res1)
  res2Dat <- as.data.frame(res2)
  res3Dat <- as.data.frame(res3)
  res5Dat <- as.data.frame(res5)
  res9Dat <- as.data.frame(res9)
  res4Dat <- as.data.frame(res4)
  res7Dat <- as.data.frame(res7)
  res8Dat <- as.data.frame(res8)
  res11Dat <- as.data.frame(res11)
  res18Dat <- as.data.frame(res18)
  res49Dat <- as.data.frame(res49)
  res59Dat <- as.data.frame(res59)
  res61Dat <- as.data.frame(res61)
  res76Dat <- as.data.frame(res76)
  res77Dat <- as.data.frame(res77)

    # need to make a column identifying the sample 
    res1Dat$Sample <- "1"
    res2Dat$Sample <- "2"
    res3Dat$Sample <- "3"
    res4Dat$Sample <- "4"
    res5Dat$Sample <- "5"
    res7Dat$Sample <- "7"
    res8Dat$Sample <- "8"
    res9Dat$Sample <- "9"
    res11Dat$Sample <- "11"
    res18Dat$Sample <- "18"
    res49Dat$Sample <- "49"
    res59Dat$Sample <- "59"
    res61Dat$Sample <- "61"
    res76Dat$Sample <- "76"
    res77Dat$Sample <- "77"

      # put all sample expression data in the same data frame 
      allSamplesExpr <- rbind(res1Dat, res2Dat, res3Dat, res4Dat, res5Dat, res7Dat, res8Dat, res9Dat, res11Dat, res18Dat, res49Dat, res59Dat, res61Dat, res76Dat, res77Dat)

# want to find how many genes are differentially expressed in 2 samples, 3 samples, 4 samples, etc
#
  # first need to filter allSamplesExpr based on p-adj level 
    allSamplesDiffExpr <- subset(allSamplesExpr, padj<0.1)
    write.csv(allSamplesDiffExpr,file="allDiffExpr.csv")
    # then ask how many times each GENEID is found in allSamplesExpr 
    library(plyr)
    geneFreq <- plyr::count(allSamplesDiffExpr, c("GENEID"))
      # want to know how many genes are DE in 1, 2, 3, 4 , etc samples 
      numGenesDE <- plyr::count(geneFreq,"freq")
        # rename columns so that I know what is going on: column 1 is how many samples a gene is DE in, column 2 is how many           genes are in that category 
        colnames(numGenesDE) <- c("numSamples", "numGenes")
          # export as .csv to use in excel or whatever
          write.csv(numGenesDE, file="numb_comm_DE_genesALL.csv")
##############################################################################################          
# want to know how many genes are differentially expressed commonly in 1,2,3 etc EUPLOID lines
#
  # put all EUPLOID samples in same data frame
    eupSamplesExpr <- rbind(res1Dat, res2Dat, res3Dat, res5Dat, res9Dat)
      # first need to filter allSamplesExpr based on p-adj level 
      eupSamplesDiffExpr <- subset(eupSamplesExpr, padj<0.1)
      #
        # then ask how many times each GENEID  is found in eupSamplesExpr 
        library(plyr)
        geneFreqEu <- plyr::count(eupSamplesDiffExpr, c("GENEID"))
        #
          # want to know how many genes are DE in 1, 2, 3, 4 , etc samples 
          numEupGenesDE <- plyr::count(geneFreqEu,"freq")
          #
            # rename columns so that I know what is going on: column 1 is how many samples a gene is DE               in, column 2 is how many genes are in that category 
            colnames(numEupGenesDE) <- c("numSamples", "numGenes")
            #
              # export as .csv to use in excel or whatever
              write.csv(numEupGenesDE, file="numb_comm_DE_genesEUP.csv")
##############################################################################################          
# want to know how many genes are differentially expressed commonly in 1,2,3 etc ANEUPLOID lines
#
  # put all ANEUPLOID samples in same data frame
    aneuSamplesExpr <- rbind(res4Dat, res7Dat, res8Dat,  res11Dat, res18Dat, res49Dat, res59Dat, res61Dat, res76Dat, res77Dat)
      # first need to filter allSamplesExpr based on p-adj level 
      aneuSamplesDiffExpr <- subset(aneuSamplesExpr, padj<0.1)
      #
        # then ask how many times each GENEID  is found in eupSamplesExpr 
        library(plyr)
        geneFreqAneu <- plyr::count(aneuSamplesDiffExpr, c("GENEID"))
        #
          # want to know how many genes are DE in 1, 2, 3, 4 , etc samples 
          numAneuGenesDE <- plyr::count(geneFreqAneu,"freq")
          #
            # rename columns so that I know what is going on: column 1 is how many samples a gene is DE               in, column 2 is how many genes are in that category 
            colnames(numAneuGenesDE) <- c("numSamples", "numGenes")
            #
              # export as .csv to use in excel or whatever
              write.csv(numAneuGenesDE, file="numb_comm_DE_genesANEU.csv")     
              
##############################################################################################          
# want to know how many genes are differentially expressed commonly in 1,2,3 etc ANEUPLOID lines
# with the SAME ANEUPLOID CHROMOSOME
  # put all samples in same data frame
    aneuChrISamplesExpr <- rbind(res7Dat,  res11Dat, res18Dat)
      aneuChrItriExpr <- rbind(res7Dat, res18Dat)
      aneuChrVtriExpr <- rbind(res4Dat, res49Dat)
      aneuChrVIItriExpr <- rbind(res59Dat, res61Dat)
      aneuChrXIItriExpr <- rbind(res18Dat, res77Dat)
      # first need to filter allSamplesExpr based on p-adj level 
      aneuChrISamplesDiffExpr <- subset(aneuChrISamplesExpr, padj<0.1)
        triChrISamplesDiffExpr <- subset(aneuChrItriExpr, padj<0.1)
        triChrVSamplesDiffExpr <- subset(aneuChrVtriExpr, padj<0.1)
        triChrVIISamplesDiffExpr <- subset(aneuChrVIItriExpr, padj<0.1)
        triChrXIISamplesDiffExpr <- subset(aneuChrXIItriExpr, padj<0.1)
      #
        # then ask how many times each GENEID  is found in eupSamplesExpr 
        library(plyr)
        geneFreqAneuChrI <- plyr::count(aneuChrISamplesDiffExpr, c("GENEID"))
          geneFreqtriChrI <- plyr::count(triChrISamplesDiffExpr, c("GENEID"))
          geneFreqtriChrV <- plyr::count(triChrVSamplesDiffExpr, c("GENEID"))
          geneFreqtriChrVII <- plyr::count(triChrVIISamplesDiffExpr, c("GENEID"))
          geneFreqtriChrXII <- plyr::count(triChrXIISamplesDiffExpr, c("GENEID"))
        #
          # want to know how many genes are DE in 1, 2, 3, 4 , etc samples 
          numAneuChrIGenesDE <- plyr::count(geneFreqAneuChrI,"freq")
            numtriChrIGenesDE <- plyr::count(geneFreqtriChrI,"freq")
            numtriChrVGenesDE <- plyr::count(geneFreqtriChrV,"freq")
            numtriChrVIIGenesDE <- plyr::count(geneFreqtriChrVII,"freq")
            numtriChrXIIGenesDE <- plyr::count(geneFreqtriChrXII,"freq")
          #
            # rename columns so that I know what is going on: column 1 is how many samples a gene is DE               in, column 2 is how many genes are in that category 
            colnames(numAneuChrIGenesDE) <- c("numSamples", "numGenes")
              colnames(numtriChrIGenesDE) <- c("numSamples", "numGenes")
              colnames(numtriChrVGenesDE) <- c("numSamples", "numGenes")
              colnames(numtriChrVIIGenesDE) <- c("numSamples", "numGenes")
              colnames(numtriChrXIIGenesDE) <- c("numSamples", "numGenes")
            #
              # export as .csv to use in excel or whatever
              write.csv(numAneuChrIGenesDE, file="numb_comm_DE_genesANEUchrI.csv")  
                write.csv(numtriChrIGenesDE, file="numb_comm_DE_genesTRIchrI.csv") 
                write.csv(numtriChrVGenesDE, file="numb_comm_DE_genesTRIchrV.csv")
                write.csv(numtriChrVIIGenesDE, file="numb_comm_DE_genesTRIchrVII.csv")
                write.csv(numtriChrXIIGenesDE, file="numb_comm_DE_genesTRIchrXII.csv")

# want to know how many genes are NOT DE on the aneuploid chromosome in aneuploid samples
  # first need to subset the data frame of gene expression for each aneuploid sample to include those genes that have a p-value above 0.1 
  #
    # then subset the data frame of genes with a p-value above 0.1 to only include genes that are located on the aneuploid chromosome 
    #
      # then compare how many of these genes are shared between samples aneuploid for the same chromosome       #
        # want to know WHAT genes are not DE - GO analysis?           
        
# put this information into a venn diagram 
  # 
  # subset the allSamplesDiffExpr data frame into vectors by sample with gene names 
        genes1DE <- subset(allSamplesDiffExpr, Sample=="1")
        write.table(genes1DE, file="genes1DE.txt")
        genes2DE <- subset(allSamplesDiffExpr, Sample=="2")
        write.table(genes2DE, file="genes2DE.txt")
        genes3DE <- subset(allSamplesDiffExpr, Sample=="3")
        write.table(genes3DE, file="genes3DE.txt")
        genes4DE <- subset(allSamplesDiffExpr, Sample=="4")
        write.table(genes4DE, file="genes4DE.txt")
        genes5DE <- subset(allSamplesDiffExpr, Sample=="5")
        write.table(genes5DE, file="genes5DE.txt")
        genes7DE <- subset(allSamplesDiffExpr, Sample=="7")
        write.table(genes7DE, file="genes7DE.txt")
        genes8DE <- subset(allSamplesDiffExpr, Sample=="8")
        write.table(genes8DE, file="genes8DE.txt")
        genes9DE <- subset(allSamplesDiffExpr, Sample=="9")
        write.table(genes9DE, file="genes9DE.txt")
        genes11DE <- subset(allSamplesDiffExpr, Sample=="11")
        write.table(genes11DE, file="genes11DE.txt")
        genes18DE <- subset(allSamplesDiffExpr, Sample=="18")
        write.table(genes18DE, file="genes18DE.txt")
        genes49DE <- subset(allSamplesDiffExpr, Sample=="49")
        write.table(genes49DE, file="genes49DE.txt")
        genes59DE <- subset(allSamplesDiffExpr, Sample=="59")
        write.table(genes59DE, file="genes59DE.txt")
        genes61DE <- subset(allSamplesDiffExpr, Sample=="61")
        write.table(genes61DE, file="genes61DE.txt")
        genes76DE <- subset(allSamplesDiffExpr, Sample=="76")
        write.table(genes76DE, file="genes76DE.txt")
        genes77DE <- subset(allSamplesDiffExpr, Sample=="77")
        write.table(genes77DE, file="genes77DE.txt")
      # trying different things to make a venn diagram 
        library(VennDiagram)
          pdf("venn_diagram.pdf")
          venn.plot <- venn.diagram(list(genes1DE$GENEID, genes2DE$GENEID,genes3DE$GENEID,genes4DE$GENEID, genes5DE$GENEID, genes7DE$GENEID, genes8DE$GENEID, genes9DE$GENEID, genes11DE$GENEID, genes18DE$GENEID, genes49DE$GENEID, genes59DE$GENEID, genes61DE$GENEID, genes76DE$GENEID, genes77DE$GENEID), NULL, fill=c("red", "green","blue","pink","orange","turquoise","yellow","purple","lightblue","lightyellow","lightred","lightgreen","lightpink","lightorange"), alpha=c(0.5,0.5,0.5,0.5,0.5,0.5,0.5,0.5,0.5,0.5,0.5,0.5,0.5,0.5), cex = 2, cat.fontface=3, category.names=c("Sample1", "Sample2","Sample3", "Sample4","Sample5","Sample7","Sample8","Sample9","Sample11","Sample18","Sample49","Sample59","Sample61","Sample76","Sample77"))
          grid.draw(venn.plot)
          dev.off()


# later want to ask how many genes are DE in only euploid samples or only aneuploid samples 
#
  # then query which samples the gene is DE in 

```

```{r common DE genes, Aneuploids, include=TRUE}

# setDT(res4Dat, keep.rownames = TRUE)[]
# setnames(res4Dat, 1, "GENEID")
# genes4DE <- subset(res4Dat,padj<0.1)


# setDT(res7Dat, keep.rownames = TRUE)[]
# setnames(res7Dat, 1, "GENEID")
# genes7DE <- subset(res7Dat,padj<0.1)


# setDT(res8Dat, keep.rownames = TRUE)[]
# setnames(res8Dat, 1, "GENEID")
# genes8DE <- subset(res8Dat,padj<0.1)


# setDT(res11Dat, keep.rownames = TRUE)[]
# setnames(res11Dat, 1, "GENEID")
# genes11DE <- subset(res11Dat,padj<0.1)


# setDT(res18Dat, keep.rownames = TRUE)[]
# setnames(res18Dat, 1, "GENEID")
# genes18DE <- subset(res18Dat,padj<0.1)


# setDT(res49Dat, keep.rownames = TRUE)[]
# setnames(res49Dat, 1, "GENEID")
# genes49DE <- subset(res49Dat,padj<0.1)


# setDT(res59Dat, keep.rownames = TRUE)[]
# setnames(res59Dat, 1, "GENEID")
# genes59DE <- subset(res59Dat,padj<0.1)


# setDT(res61Dat, keep.rownames = TRUE)[]
# setnames(res61Dat, 1, "GENEID")
# genes61DE <- subset(res61Dat,padj<0.1)


# setDT(res76Dat, keep.rownames = TRUE)[]
# setnames(res76Dat, 1, "GENEID")
# genes76DE <- subset(res76Dat,padj<0.1)


# setDT(res77Dat, keep.rownames = TRUE)[]
# setnames(res77Dat, 1, "GENEID")
# genes77DE <- subset(res77Dat,padj<0.1)

#remove genes that are commonly DE in euploid lines 
# genes4DE.r <- anti_join(genes4DE, common1235.9,by="GENEID")
# genes7DE.r <- anti_join(genes7DE, common1235.9,by="GENEID")
# genes8DE.r <- anti_join(genes8DE, common1235.9,by="GENEID")
# genes11DE.r <- anti_join(genes11DE, common1235.9,by="GENEID")
# genes18DE.r <- anti_join(genes18DE, common1235.9,by="GENEID")
# genes49DE.r <- anti_join(genes49DE, common1235.9,by="GENEID")
# genes59DE.r <- anti_join(genes59DE, common1235.9,by="GENEID")
# genes61DE.r <- anti_join(genes61DE, common1235.9,by="GENEID")
# genes76DE.r <- anti_join(genes76DE, common1235.9,by="GENEID")
# genes77DE.r <- anti_join(genes77DE, common1235.9,by="GENEID")

#find common DE genes in aneuploids with same chromosome aneuploid 
# chrI.tri <- inner_join(genes7DE,genes18DE, by="GENEID")
# matchedI <- intersect(chrI.tri$GENEID, genes$GENEID)
# keepI <- chrI.tri$GENEID %in% matchedI
# chrI.tri <- chrI.tri[keepI,]
# keepGen <- genes$GENEID %in% matchedI
# Gen <- genes[keepGen,]
# chrI.tri <- cbind(Gen$TXCHROM, chrI.tri)
# 
# chrI.all <- inner_join(chrI.tri, genes11DE, by="GENEID")
# matchedI <- intersect(chrI.all$GENEID, genes$GENEID)
# keepI <- chrI.all$GENEID %in% matchedI
# chrI.all <- chrI.all[keepI,]
# 
# chrV.tri <- inner_join(genes4DE, genes49DE, by="GENEID")
# matchedV <- intersect(chrV.tri$GENEID, genes$GENEID)
# keepV <- chrV.tri$GENEID %in% matchedV
# chrV.tri <- chrV.tri[keepI,]
# keepGen <- genes$GENEID %in% matchedV
# Gen <- genes[keepGen,]
# chrV.tri <- cbind(Gen$TXCHROM, chrV.tri)
# 
# chrVII.tri <- inner_join(genes59DE, genes61DE, by="GENEID")
# matchedVII <- intersect(chrVII.tri$GENEID, genes$GENEID)
# keepVII <- chrVII.tri$GENEID %in% matchedVII
# chrVII.tri <- chrVII.tri[keepVII,]
# keepGen <- genes$GENEID %in% matchedVII
# Gen <- genes[keepGen,]
# chrVII.tri <- cbind(Gen$TXCHROM, chrVII.tri)
# 
# chrXII.tri <- inner_join(genes18DE, genes77DE, by="GENEID")
# matchedXII <- intersect(chrXII.tri$GENEID, genes$GENEID)
# keepXII <- chrXII.tri$GENEID %in% matchedXII
# chrXII.tri <- chrXII.tri[keepXII,]
# keepGen <- genes$GENEID %in% matchedXII
# Gen <- genes[keepGen,]
# chrXII.tri <- cbind(Gen$TXCHROM, chrXII.tri)

##any commonly DE genes between 2+ aneuploids?

#that are NOT commonly DE in euploid lines 
# dupRows <- dupsBetweenGroups(allSamplesDE, "Sample")

#find any genes on aneuploid chromosomes that are NOT DE 
# notDE4 <- subset(res4Dat,padj>0.1)
# notDE7 <- subset(res7Dat,padj>0.1)
# notDE8 <- subset(res8Dat,padj>0.1)
# notDE11 <- subset(res11Dat,padj>0.1)
# notDE18 <- subset(res18Dat,padj>0.1)
# notDE49 <- subset(res49Dat,padj>0.1)
# notDE59 <- subset(res59Dat,padj>0.1)
# notDE61 <- subset(res61Dat,padj>0.1)
# notDE76 <- subset(res76Dat,padj>0.1)
# notDE77 <- subset(res77Dat,padj>0.1)

# notDECom <- inner_join(notDE4, notDE7, by="GENEID")
# notDECom <- inner_join(notDECom, notDE8, by="GENEID")
# notDECom <- inner_join(notDECom, notDE11, by="GENEID")
# notDECom <- inner_join(notDECom, notDE18, by="GENEID")
# notDECom <- inner_join(notDECom, notDE49, by="GENEID")
# notDECom <- inner_join(notDECom, notDE59, by="GENEID")
# notDECom <- inner_join(notDECom, notDE61, by="GENEID")
# notDECom <- inner_join(notDECom, notDE76, by="GENEID")
# notDECom <- inner_join(notDECom, notDE77, by="GENEID")

```

More information about extracting specific coefficients from a fitted
*DESeqDataSet* object can be found in the help page `?results`.
The use of the `contrast` argument is also further discussed [below](#contrasts).

<a name="lfcShrink"/>

### Log fold change shrinkage for visualization and ranking

Shrinkage of effect size (LFC estimates) is useful for visualization
and ranking of genes. To shrink the LFC, we pass the `dds`
object to the function `lfcShrink`. Below we specify to use the
*apeglm* method for effect size shrinkage [@Zhu2018], which improves
on the previous estimator.

We provide the `dds` object and the name or number of the
coefficient we want to shrink, where the number refers to the order
of the coefficient as it appears in `resultsNames(dds)`.

```{r lfcShrink}
resultsNames(dds)
resLFC2 <- lfcShrink(ddsNoAneuInNorm, coef="condition_Holly_2_vs_Holly_Anc", type="apeglm")
resLFC2
summary(resLFC2)
res21LFC <- lfcShrink(ddsNoAneuInNorm, coef="condition_Holly_21_vs_Holly_Anc", type="apeglm")
res21LFC
summary(res21LFC)

```

Shrinkage estimation is discussed more in a [later section](#altshrink).

<a name="parallel"/>

### Using parallelization

The above steps should take less than 30 seconds for most
analyses. For experiments with complex designs and many samples
(e.g. dozens of coefficients, ~100s of samples), one
can take advantage of parallelized computation. Parallelizing `DESeq`,
`results`, and `lfcShrink` can be easily accomplished by loading the
BiocParallel package, and then setting the following arguments:
`parallel=TRUE` and `BPPARAM=MulticoreParam(4)`, for example,
splitting the job over 4 cores. Note that `results` for coefficients
or contrasts listed in `resultsNames(dds)` is fast and will not need
parallelization. As an alternative to `BPPARAM`, one can `register`
cores at the beginning of an analysis, and then just specify
`parallel=TRUE` to the functions when called.

```{r parallel, eval=FALSE}
source("https://bioconductor.org/biocLite.R")
        biocLite("BiocParallel")
library("BiocParallel")
register(MulticoreParam(4))
```

### p-values and adjusted p-values

We can order our results table by the smallest *p* value:

```{r resOrder}
#Holly_GC_Anc vs Holly_2
res2Ordered <- res2[order(res2$pvalue),]

res21Ordered <- res21[order(res21$pvalue),]

```

We can summarize some basic tallies using the
*summary* function.

```{r sumRes, fdrtool}
#plot histograms of the pvalues, identify lines that look concerning 
hist(res1Def$pvalue,col="purple", main="1 vs Anc, with aneuploid c'somes", xlab="p values")
res1Def

hist(res2Def$pvalue,col="purple", main="2 vs Anc, with aneuploid c'somes", xlab="p values")
hist(res3Def$pvalue,col="purple", main="3 vs Anc, with aneuploid c'somes", xlab="p values")
hist(res4Def$pvalue,col="purple", main="4 vs Anc, with aneuploid c'somes", xlab="p values")
hist(res5Def$pvalue,col="purple", main="5 vs Anc, with aneuploid c'somes", xlab="p values")
hist(res6Def$pvalue,col="purple", main="6 vs Anc, with aneuploid c'somes", xlab="p values")
hist(res7Def$pvalue,col="purple", main="7 vs Anc, with aneuploid c'somes", xlab="p values")
hist(res8Def$pvalue,col="purple", main="8 vs Anc, with aneuploid c'somes", xlab="p values")
hist(res9Def$pvalue,col="purple", main="9 vs Anc, with aneuploid c'somes", xlab="p values")
hist(res11Def$pvalue,col="purple", main="11 vs Anc, with aneuploid c'somes", xlab="p values")
hist(res18Def$pvalue,col="purple", main="18 vs Anc, with aneuploid c'somes", xlab="p values")
hist(res21Def$pvalue,col="purple", main="21 vs Anc, with aneuploid c'somes", xlab="p values")
hist(res31Def$pvalue,col="purple", main="31 vs Anc, with aneuploid c'somes", xlab="p values")
hist(res49Def$pvalue,col="purple", main="49 vs Anc, with aneuploid c'somes", xlab="p values")
hist(res59Def$pvalue,col="purple", main="59 vs Anc, with aneuploid c'somes", xlab="p values")
hist(res61Def$pvalue,col="purple", main="61 vs Anc, with aneuploid c'somes", xlab="p values")
hist(res66Def$pvalue,col="purple", main="66 vs Anc, with aneuploid c'somes", xlab="p values")
hist(res69Def$pvalue,col="purple", main="69 vs Anc, with aneuploid c'somes", xlab="p values")
hist(res76Def$pvalue,col="purple", main="76 vs Anc, with aneuploid c'somes", xlab="p values")
hist(res77Def$pvalue,col="purple", main="77 vs Anc, with aneuploid c'somes", xlab="p values")


##without aneuploid chromosomes
hist(res1$pvalue,col="turquoise", main="1 vs Anc, withoutout aneuploid c'somes", xlab="p values")
hist(res2$pvalue,col="turquoise", main="2 vs Anc, without aneuploid c'somes", xlab="p values")
hist(res3$pvalue,col="turquoise", main="3 vs Anc, without aneuploid c'somes", xlab="p values")
hist(res4$pvalue,col="turquoise", main="4 vs Anc, without aneuploid c'somes", xlab="p values")
hist(res5$pvalue,col="turquoise", main="5 vs Anc, without aneuploid c'somes", xlab="p values")
hist(res6$pvalue,col="turquoise", main="6 vs Anc, without aneuploid c'somes", xlab="p values")
hist(res7$pvalue,col="turquoise", main="7 vs Anc, without aneuploid c'somes", xlab="p values")
hist(res8$pvalue,col="turquoise", main="8 vs Anc, without aneuploid c'somes", xlab="p values")
hist(res9$pvalue,col="turquoise", main="9 vs Anc, without aneuploid c'somes", xlab="p values")
hist(res11$pvalue,col="turquoise", main="11 vs Anc, without aneuploid c'somes", xlab="p values")
hist(res18$pvalue,col="turquoise", main="18 vs Anc, without aneuploid c'somes", xlab="p values")
hist(res21$pvalue,col="turquoise", main="21 vs Anc, without aneuploid c'somes", xlab="p values")
hist(res31$pvalue,col="turquoise", main="31 vs Anc, without aneuploid c'somes", xlab="p values")
hist(res49$pvalue,col="turquoise", main="49 vs Anc, without aneuploid c'somes", xlab="p values")
hist(res59$pvalue,col="turquoise", main="59 vs Anc, without aneuploid c'somes", xlab="p values")
hist(res61$pvalue,col="turquoise", main="61 vs Anc, without aneuploid c'somes", xlab="p values")
hist(res66$pvalue,col="turquoise", main="66 vs Anc, without aneuploid c'somes", xlab="p values")
hist(res69$pvalue,col="turquoise", main="69 vs Anc, without aneuploid c'somes", xlab="p values")
hist(res76$pvalue,col="turquoise", main="76 vs Anc, without aneuploid c'somes", xlab="p values")
hist(res77$pvalue,col="turquoise", main="77 vs Anc, without aneuploid c'somes", xlab="p values")

#Holly_GC_Anc vs Holly_2
summary(res2)

summary(res21)

summary(res7)

summary(res18)
sigGenes18 <- rownames(subset(res18,padj<0.1))

genesSig18 <- as.data.frame(subset(genes, GENEID %in% sigGenes18))

sigGenes7 <- rownames(subset(res7,padj<0.1))

genesSig7 <- as.data.frame(subset(genes, GENEID %in% sigGenes7))


summary(resLFC21)

View(genes)

###use fdrtool to estimate null variance for each sample
##empirical null modeling
ddsNoAneuInNorm
length(colnames(ddsNoAneuInNorm))
#linesGC <- colnames(ddsNoAneuInNorm)
#resGC <- as.factor(c("res1","res2","res3","res4","res5","res6","res7","res8","res9","res11","res18","res21","res31","res49","res59","res61","res66","res69","res76","res77"))
#View(res1)
#res1.test <- as.data.frame(res1)
#make loop to do this (or use apply)
#lfcUp <- matrix(data=NA,nrow=nrow(ddsNoAneuInNorm),ncol=length(resGC))
#is.list(lfcUp)
#i=1
#res
#need to turn all results files into data frames
#giving up for now...may come back to this later
#for (i in 1:length(resGC)) {
#  res <- as.data.frame(res[!is.na(res$value),])
#  res <- as.data.frame(res[!is.na(res$padj),])
#  res <- res[,-which(colnames(res)=="padj")]
#  ind <- grep(as.character(linesGC[i]),names)
#  cols <- lcpmGC[,ind]
#  cols <- matrix(apply(cols,1,var))
#  rownames(cols) <- c()
#  colnames(cols) <- c()
#  vari[,i] <- cols
#}

library(fdrtool)
################################ Default: Aneuploid chromosomes left in 
#remove the genes filtered out by independent filtering and dispersion outliers 
res1Def <- res1Def[!is.na(res1Def$pvalue),]
res1Def <- res1Def[!is.na(res1Def$padj),]
#remove original adjusted p values
res1Def <- res1Def[,-which(names(res1Def)=="padj")]
#use the z-scores from DESeq2 as input to fdrtool to re-estimate p values
FDR.res1Def <- fdrtool(res1Def$stat,statistic="normal",plot=T)
FDR.res1Def$param[1,"sd"]
#add the new BH-adjusted p-values to the results frame 
res1Def[,"padj"] <- p.adjust(FDR.res1Def$pval, method="BH")
#plot the histogram of the "Correct" pvalues 
hist(FDR.res1Def$pval,col="royalblue4", main="1 vs Anc, correct null model", xlab="CORRECTED p values")
#test how many of the genes are now differentially expressed with this new null model
table(res1Def[,"padj"] < 0.1)
sigGenes1Def <- rownames(subset(res1Def,padj<0.1))
genesSig1Def <- as.data.frame(subset(genes, GENEID %in% sigGenes1Def))



library(fdrtool)
###########line 1 
#remove the genes filtered out by independent filtering and dispersion outliers 
res1 <- res1[!is.na(res1$pvalue),]
res1 <- res1[!is.na(res1$padj),]
#remove original adjusted p values
res1 <- res1[,-which(names(res1)=="padj")]
res1
summary(is.na(res1))

#use the z-scores from DESeq2 as input to fdrtool to re-estimate p values
FDR.res1 <- fdrtool(res1$pvalue,statistic="pvalue",plot=T)
#FDR.res1$param[1,"sd"]
#new estimated null model variance is 0.8267165, lower than 1 (theoretical one)
#add the new BH-adjusted p-values to the results frame 
summary(res1)
res1[,"padj"] <- p.adjust(FDR.res1$pval, method="BH")
#plot the histogram of the "Correct" pvalues 
hist(FDR.res1$pval,col="royalblue4", main="1 vs Anc, correct null model", xlab="CORRECTED p values")
#test how many of the genes are now differentially expressed with this new null model
table(res1[,"padj"] < 0.1)
sigGenes1 <- rownames(subset(res1,padj<0.1))
#genesSig1 <- as.data.frame(subset(genes, GENEID %in% sigGenes1))
summary(res1)

###########line 2 
#remove the genes filtered out by independent filtering and dispersion outliers
res2 <- res2[!is.na(res2$pvalue),]
res2 <- res2[!is.na(res2$padj),]
#remove original adjusted p values
res2 <- res2[,-which(names(res2)=="padj")]
#use the z-scores from DESeq2 as input to fdrtool to re-estimate p values
FDR.res2 <- fdrtool(res2$pvalue,statistic="pvalue",plot=T)
#FDR.res2$param[1,"sd"]
#new estimated null model variance is 0.8267165, lower than 1 (theoretical one)
#add the new BH-adjusted p-values to the results frame 
res2[,"padj"] <- p.adjust(FDR.res2$pval, method="BH")
#plot the histogram of the "Correct" pvalues 
hist(FDR.res2$pval,col="royalblue4", main="2 vs Anc, correct null model", xlab="CORRECTED p values")
#test how many of the genes are now differentially expressed with this new null model
table(res2[,"padj"] < 0.1)
sigGenes2 <- rownames(subset(res2,padj<0.1))
summary(res2)
#genesSig2 <- as.data.frame(subset(genes, GENEID %in% sigGenes2))


#remove the genes filtered out by independent filtering and dispersion outliers 
res21 <- res21[!is.na(res21$pvalue),]
res21 <- res21[!is.na(res21$padj),]
#remove original adjusted p values
res21 <- res21[,-which(names(res21)=="padj")]
#use the z-scores from DESeq2 as input to fdrtool to re-estimate p values
FDR.res21 <- fdrtool(res21$stat,statistic="normal",plot=T)

#FDR.res21$param[1,"sd"]
#new estimated null model variance is 0.8267165, lower than 1 (theoretical one)

#add the new BH-adjusted p-values to the results frame 
res21[,"padj"] <- p.adjust(FDR.res21$pval, method="BH")

#plot the histogram of the "Correct" pvalues 
hist(FDR.res21$pval,col="royalblue4", main="21 vs Anc, correct null model", xlab="CORRECTED p values")

#test how many of the genes are now differentially expressed with this new null model
table(res21[,"padj"] < 0.1)
summary(res21)
sigGenes21 <- rownames(subset(res21,padj<0.1))
sigGenes21
genesSig21 <- as.data.frame(subset(genesNoAneu, GENEID %in% sigGenes21))

###########################################################################
##do the same for line 7 that actually has 3 replicates (21 might just need to be discarded)

#remove the genes filtered out by independent filtering and dispersion outliers 
res7 <- res7[!is.na(res7$pvalue),]
res7 <- res7[!is.na(res7$padj),]
#remove original adjusted p values
res7 <- res7[,-which(names(res7)=="padj")]
#use the z-scores from DESeq2 as input to fdrtool to re-estimate p values
FDR.res7 <- fdrtool(res7$stat,statistic="normal",plot=T)

#FDR.res7$param[1,"sd"]
#new estimated null model variance is 0.6807261, lower than 1 (theoretical one)

#add the new BH-adjusted p-values to the results frame 
res7[,"padj"] <- p.adjust(FDR.res7$pval, method="BH")

#plot the histogram of the "Correct" pvalues 
hist(FDR.res7$pval,col="royalblue4", main="7 vs Anc, correct null model", xlab="CORRECTED p values")

#test how many of the genes are now differentially expressed with this new null model
###now there are 50! 50 more than 0! 
table(res7[,"padj"] < 0.1)

#plot the MA plot
plotMA(res7)
summary(res7)
sigGenes7 <- rownames(subset(res7,padj<0.1))

genesSig7 <- as.data.frame(subset(genesNoAneu, GENEID %in% sigGenes7))


#remove the genes filtered out by independent filtering and dispersion outliers 
res69 <- res69[!is.na(res69$pvalue),]
res69 <- res69[!is.na(res69$padj),]
#remove original adjusted p values
res69 <- res69[,-which(names(res69)=="padj")]
#use the z-scores from DESeq2 as input to fdrtool to re-estimate p values
FDR.res69 <- fdrtool(res69$stat,statistic="normal",plot=T)

FDR.res69$param[1,"sd"]
#new estimated null model variance is 0.6807261, lower than 1 (theoretical one)

#add the new BH-adjusted p-values to the results frame 
res69[,"padj"] <- p.adjust(FDR.res69$pval, method="BH")

#plot the histogram of the "Correct" pvalues 
hist(FDR.res69$pval,col="royalblue4", main="69 vs Anc, correct null model", xlab="CORRECTED p values")

#test how many of the genes are now differentially expressed with this new null model
###now there are 50! 50 more than 0! 
table(res69[,"padj"] < 0.1)

#plot the MA plot
plotMA(res69)
summary(res69)
sigGenes69 <- rownames(subset(res69,padj<0.1))

genesSig69 <- as.data.frame(subset(genesNoAneu, GENEID %in% sigGenes69))
summary(res69)

#remove the genes filtered out by independent filtering and dispersion outliers 
res3 <- res3[!is.na(res3$pvalue),]
res3 <- res3[!is.na(res3$padj),]
#remove original adjusted p values
res3 <- res3[,-which(names(res3)=="padj")]
#use the z-scores from DESeq2 as input to fdrtool to re-estimate p values
FDR.res3 <- fdrtool(res3$pvalue,statistic="normal",plot=T)

FDR.res3$param[1,"sd"]
#new estimated null model variance is 0.6807261, lower than 1 (theoretical one)

#add the new BH-adjusted p-values to the results frame 
FDR.res3$qval
res3[,"padj"] <- p.adjust(FDR.res3$pval, method="BH")

#plot the histogram of the "Correct" pvalues 
hist(FDR.res3$pval,col="royalblue4", main="3 vs Anc, correct null model", xlab="CORRECTED p values")

#test how many of the genes are now differentially expressed with this new null model
###now there are 50! 50 more than 0! 
table(res3[,"padj"] < 0.1)

#plot the MA plot
plotMA(res3)

sigGenes3 <- rownames(subset(res3,padj<0.1))

genesSig3 <- as.data.frame(subset(genesNoAneu, GENEID %in% sigGenes3))

summary(res3)

#remove the genes filtered out by independent filtering and dispersion outliers 
res9 <- res9[!is.na(res9$pvalue),]
res9 <- res9[!is.na(res9$padj),]
#remove original adjusted p values
res9 <- res9[,-which(names(res9)=="padj")]
#use the z-scores from DESeq2 as input to fdrtool to re-estimate p values
FDR.res9 <- fdrtool(res9$stat,statistic="normal",plot=T)

FDR.res9$param[1,"sd"]
#new estimated null model variance is 0.6807261, lower than 1 (theoretical one)

#add the new BH-adjusted p-values to the results frame 
res9[,"padj"] <- p.adjust(FDR.res9$pval, method="BH")

#plot the histogram of the "Correct" pvalues 
hist(FDR.res9$pval,col="royalblue4", main="9 vs Anc, correct null model", xlab="CORRECTED p values")

#test how many of the genes are now differentially expressed with this new null model
###now there are 50! 50 more than 0! 
table(res9[,"padj"] < 0.1)

#plot the MA plot
plotMA(res9)

sigGenes9 <- rownames(subset(res9,padj<0.1))

genesSig9 <- as.data.frame(subset(genesNoAneu, GENEID %in% sigGenes9))

summary(res9)

#remove the genes filtered out by independent filtering and dispersion outliers 
res4 <- res4[!is.na(res4$pvalue),]
res4 <- res4[!is.na(res4$padj),]
#remove original adjusted p values
res4 <- res4[,-which(names(res4)=="padj")]
#use the z-scores from DESeq2 as input to fdrtool to re-estimate p values
FDR.res4 <- fdrtool(res4$stat,statistic="normal",plot=T)

FDR.res4$param[1,"sd"]
#new estimated null model variance is 0.6807261, lower than 1 (theoretical one)

#add the new BH-adjusted p-values to the results frame 
res4[,"padj"] <- p.adjust(FDR.res4$pval, method="BH")

#plot the histogram of the "Correct" pvalues 
hist(FDR.res4$pval,col="royalblue4", main="4 vs Anc, correct null model", xlab="CORRECTED p values")

#test how many of the genes are now differentially expressed with this new null model
###now there are 50! 50 more than 0! 
table(res4[,"padj"] < 0.1)

#plot the MA plot
plotMA(res4)

sigGenes4 <- rownames(subset(res4,padj<0.1))

genesSig4 <- as.data.frame(subset(genesNoAneu, GENEID %in% sigGenes4))

summary(res4)

#remove the genes filtered out by independent filtering and dispersion outliers 
res5 <- res5[!is.na(res5$pvalue),]
res5 <- res5[!is.na(res5$padj),]
#remove original adjusted p values
res5 <- res5[,-which(names(res5)=="padj")]
#use the z-scores from DESeq2 as input to fdrtool to re-estimate p values
FDR.res5 <- fdrtool(res5$stat,statistic="normal",plot=T)

FDR.res5$param[1,"sd"]
#new estimated null model variance is 0.6807261, lower than 1 (theoretical one)

#add the new BH-adjusted p-values to the results frame 
res5[,"padj"] <- p.adjust(FDR.res5$pval, method="BH")

#plot the histogram of the "Correct" pvalues 
hist(FDR.res5$pval,col="royalblue4", main="5 vs Anc, correct null model", xlab="CORRECTED p values")

#test how many of the genes are now differentially expressed with this new null model
###now there are 50! 50 more than 0! 
table(res5[,"padj"] < 0.1)

#plot the MA plot
plotMA(res5)

sigGenes5 <- rownames(subset(res5,padj<0.1))

genesSig5 <- as.data.frame(subset(genesNoAneu, GENEID %in% sigGenes5))

summary(res5)

#remove the genes filtered out by independent filtering and dispersion outliers 
res6 <- res6[!is.na(res6$pvalue),]
res6 <- res6[!is.na(res6$padj),]
#remove original adjusted p values
res6 <- res6[,-which(names(res6)=="padj")]
#use the z-scores from DESeq2 as input to fdrtool to re-estimate p values
FDR.res6 <- fdrtool(res6$stat,statistic="normal",plot=T)

FDR.res6$param[1,"sd"]
#new estimated null model variance is 0.6807261, lower than 1 (theoretical one)

#add the new BH-adjusted p-values to the results frame 
res6[,"padj"] <- p.adjust(FDR.res6$pval, method="BH")

#plot the histogram of the "Correct" pvalues 
hist(FDR.res6$pval,col="royalblue4", main="6 vs Anc, correct null model", xlab="CORRECTED p values")

#test how many of the genes are now differentially expressed with this new null model
###now there are 60! 60 more than 0! 
table(res6[,"padj"] < 0.1)

#plot the MA plot
plotMA(res6)

sigGenes6 <- rownames(subset(res6,padj<0.1))

genesSig6 <- as.data.frame(subset(genesNoAneu, GENEID %in% sigGenes6))

summary(res6)

#remove the genes filtered out by independent filtering and dispersion outliers 
res8 <- res8[!is.na(res8$pvalue),]
res8 <- res8[!is.na(res8$padj),]
#remove original adjusted p values
res8 <- res8[,-which(names(res8)=="padj")]
#use the z-scores from DESeq2 as input to fdrtool to re-estimate p values
FDR.res8 <- fdrtool(res8$stat,statistic="normal",plot=T)

FDR.res8$param[1,"sd"]
#new estimated null model variance is 0.8807281, lower than 1 (theoretical one)

#add the new BH-adjusted p-values to the results frame 
res8[,"padj"] <- p.adjust(FDR.res8$pval, method="BH")

#plot the histogram of the "Correct" pvalues 
hist(FDR.res8$pval,col="royalblue4", main="8 vs Anc, correct null model", xlab="CORRECTED p values")

#test how many of the genes are now differentially expressed with this new null model
###now there are 80! 80 more than 0! 
table(res8[,"padj"] < 0.1)

#plot the MA plot
plotMA(res8)

sigGenes8 <- rownames(subset(res8,padj<0.1))

genesSig8 <- as.data.frame(subset(genesNoAneu, GENEID %in% sigGenes8))

summary(res8)

#remove the genes filtered out by independent filtering and dispersion outliers 
res11 <- res11[!is.na(res11$pvalue),]
res11 <- res11[!is.na(res11$padj),]
#remove original adjusted p values
res11 <- res11[,-which(names(res11)=="padj")]
#use the z-scores from DESeq2 as input to fdrtool to re-estimate p values
FDR.res11 <- fdrtool(res11$stat,statistic="normal",plot=T)

FDR.res11$param[1,"sd"]
#new estimated null model variance is 0.1111072111, lower than 1 (theoretical one)

#add the new BH-adjusted p-values to the results frame 
res11[,"padj"] <- p.adjust(FDR.res11$pval, method="BH")

#plot the histogram of the "Correct" pvalues 
hist(FDR.res11$pval,col="royalblue4", main="11 vs Anc, correct null model", xlab="CORRECTED p values")

#test how many of the genes are now differentially expressed with this new null model
###now there are 110! 110 more than 0! 
table(res11[,"padj"] < 0.1)

#plot the MA plot
plotMA(res11)

sigGenes11 <- rownames(subset(res11,padj<0.1))

genesSig11 <- as.data.frame(subset(genesNoAneu, GENEID %in% sigGenes11))

summary(res11)

#remove the genes filtered out by independent filtering and dispersion outliers 
res18 <- res18[!is.na(res18$pvalue),]
res18 <- res18[!is.na(res18$padj),]
#remove original adjusted p values
res18 <- res18[,-which(names(res18)=="padj")]
#use the z-scores from DESeq2 as input to fdrtool to re-estimate p values
FDR.res18 <- fdrtool(res18$stat,statistic="normal",plot=T)

FDR.res18$param[1,"sd"]
#new estimated null model variance is 0.1818072181, lower than 1 (theoretical one)

#add the new BH-adjusted p-values to the results frame 
res18[,"padj"] <- p.adjust(FDR.res18$pval, method="BH")

#plot the histogram of the "Correct" pvalues 
hist(FDR.res18$pval,col="royalblue4", main="18 vs Anc, correct null model", xlab="CORRECTED p values")

#test how many of the genes are now differentially expressed with this new null model
###now there are 180! 180 more than 0! 
table(res18[,"padj"] < 0.1)

#plot the MA plot
plotMA(res18)

sigGenes18 <- rownames(subset(res18,padj<0.1))

genesSig18 <- as.data.frame(subset(genesNoAneu, GENEID %in% sigGenes18))

summary(res18)

#remove the genes filtered out by independent filtering and dispersion outliers 
res31 <- res31[!is.na(res31$pvalue),]
res31 <- res31[!is.na(res31$padj),]
#remove original adjusted p values
res31 <- res31[,-which(names(res31)=="padj")]
#use the z-scores from DESeq2 as input to fdrtool to re-estimate p values
FDR.res31 <- fdrtool(res31$stat,statistic="normal",plot=T)

FDR.res31$param[1,"sd"]
#new estimated null model variance is 0.3131072311, lower than 1 (theoretical one)

#add the new BH-adjusted p-values to the results frame 
res31[,"padj"] <- p.adjust(FDR.res31$pval, method="BH")

#plot the histogram of the "Correct" pvalues 
hist(FDR.res31$pval,col="royalblue4", main="31 vs Anc, correct null model", xlab="CORRECTED p values")

#test how many of the genes are now differentially expressed with this new null model
###now there are 310! 310 more than 0! 
table(res31[,"padj"] < 0.1)

#plot the MA plot
plotMA(res31)

sigGenes31 <- rownames(subset(res31,padj<0.1))

genesSig31 <- as.data.frame(subset(genesNoAneu, GENEID %in% sigGenes31))

summary(res31)

#remove the genes filtered out by independent filtering and dispersion outliers 
res49 <- res49[!is.na(res49$pvalue),]
res49 <- res49[!is.na(res49$padj),]
#remove original adjusted p values
res49 <- res49[,-which(names(res49)=="padj")]
#use the z-scores from DESeq2 as input to fdrtool to re-estimate p values
FDR.res49 <- fdrtool(res49$stat,statistic="normal",plot=T)

FDR.res49$param[1,"sd"]
#new estimated null model variance is 0.4949072491, lower than 1 (theoretical one)

#add the new BH-adjusted p-values to the results frame 
res49[,"padj"] <- p.adjust(FDR.res49$pval, method="BH")

#plot the histogram of the "Correct" pvalues 
hist(FDR.res49$pval,col="royalblue4", main="49 vs Anc, correct null model", xlab="CORRECTED p values")
 
#test how many of the genes are now differentially expressed with this new null model
###now there are 490! 490 more than 0! 
table(res49[,"padj"] < 0.1)

#plot the MA plot
plotMA(res49)

sigGenes49 <- rownames(subset(res49,padj<0.1))

genesSig49 <- as.data.frame(subset(genesNoAneu, GENEID %in% sigGenes49))

summary(res49)

#remove the genes filtered out by independent filtering and dispersion outliers 
res61 <- res61[!is.na(res61$pvalue),]
res61 <- res61[!is.na(res61$padj),]
#remove original adjusted p values
res61 <- res61[,-which(names(res61)=="padj")]
#use the z-scores from DESeq2 as input to fdrtool to re-estimate p values
FDR.res61 <- fdrtool(res61$stat,statistic="normal",plot=T)

FDR.res61$param[1,"sd"]
#new estimated null model variance is 0.6161072611, lower than 1 (theoretical one)

#add the new BH-adjusted p-values to the results frame 
res61[,"padj"] <- p.adjust(FDR.res61$pval, method="BH")

#plot the histogram of the "Correct" pvalues 
hist(FDR.res61$pval,col="royalblue4", main="61 vs Anc, correct null model", xlab="CORRECTED p values")
 
#test how many of the genes are now differentially expressed with this new null model
###now there are 610! 610 more than 0! 
table(res61[,"padj"] < 0.1)

#plot the MA plot
plotMA(res61)

sigGenes61 <- rownames(subset(res61,padj<0.1))

genesSig61 <- as.data.frame(subset(genesNoAneu, GENEID %in% sigGenes61))

summary(res61)

#remove the genes filtered out by independent filtering and dispersion outliers 
res59 <- res59[!is.na(res59$pvalue),]
res59 <- res59[!is.na(res59$padj),]
#remove original adjusted p values
res59 <- res59[,-which(names(res59)=="padj")]
#use the z-scores from DESeq2 as input to fdrtool to re-estimate p values
FDR.res59 <- fdrtool(res59$stat,statistic="normal",plot=T)

FDR.res59$param[1,"sd"]
#new estimated null model variance is 0.5959072591, lower than 1 (theoretical one)

#add the new BH-adjusted p-values to the results frame 
res59[,"padj"] <- p.adjust(FDR.res59$pval, method="BH")

#plot the histogram of the "Correct" pvalues 
hist(FDR.res59$pval,col="royalblue4", main="59 vs Anc, correct null model", xlab="CORRECTED p values")
 
#test how many of the genes are now differentially expressed with this new null model
###now there are 590! 590 more than 0! 
table(res59[,"padj"] < 0.1)

#plot the MA plot
plotMA(res59)

sigGenes59 <- rownames(subset(res59,padj<0.1))

genesSig59 <- as.data.frame(subset(genesNoAneu, GENEID %in% sigGenes59))

summary(res59)

#remove the genes filtered out by independent filtering and dispersion outliers 
res66 <- res66[!is.na(res66$pvalue),]
res66 <- res66[!is.na(res66$padj),]
#remove original adjusted p values
res66 <- res66[,-which(names(res66)=="padj")]
#use the z-scores from DESeq2 as input to fdrtool to re-estimate p values
FDR.res66 <- fdrtool(res66$stat,statistic="normal",plot=T)

FDR.res66$param[1,"sd"]
#new estimated null model variance is 0.6666072661, lower than 1 (theoretical one)

#add the new BH-adjusted p-values to the results frame 
res66[,"padj"] <- p.adjust(FDR.res66$pval, method="BH")

#plot the histogram of the "Correct" pvalues 
hist(FDR.res66$pval,col="royalblue4", main="66 vs Anc, correct null model", xlab="CORRECTED p values")
 
#test how many of the genes are now differentially expressed with this new null model
###now there are 660! 660 more than 0! 
table(res66[,"padj"] < 0.1)

#plot the MA plot
plotMA(res66)

sigGenes66 <- rownames(subset(res66,padj<0.1))

genesSig66 <- as.data.frame(subset(genesNoAneu, GENEID %in% sigGenes66))

summary(res66)

#remove the genes filtered out by independent filtering and dispersion outliers 
res76 <- res76[!is.na(res76$pvalue),]
res76 <- res76[!is.na(res76$padj),]
#remove original adjusted p values
res76 <- res76[,-which(names(res76)=="padj")]
#use the z-scores from DESeq2 as input to fdrtool to re-estimate p values
FDR.res76 <- fdrtool(res76$stat,statistic="normal",plot=T)

FDR.res76$param[1,"sd"]
#new estimated null model variance is 0.7676072761, lower than 1 (theoretical one)

#add the new BH-adjusted p-values to the results frame 
res76[,"padj"] <- p.adjust(FDR.res76$pval, method="BH")

#plot the histogram of the "Correct" pvalues 
hist(FDR.res76$pval,col="royalblue4", main="76 vs Anc, correct null model", xlab="CORRECTED p values")
 
#test how many of the genes are now differentially expressed with this new null model
###now there are 760! 760 more than 0! 
table(res76[,"padj"] < 0.1)

#plot the MA plot
plotMA(res76)

sigGenes76 <- rownames(subset(res76,padj<0.1))

genesSig76 <- as.data.frame(subset(genesNoAneu, GENEID %in% sigGenes76))

summary(res76)

#remove the genes filtered out by independent filtering and dispersion outliers 
res77 <- res77[!is.na(res77$pvalue),]
res77 <- res77[!is.na(res77$padj),]
#remove original adjusted p values
res77 <- res77[,-which(names(res77)=="padj")]
#use the z-scores from DESeq2 as input to fdrtool to re-estimate p values
FDR.res77 <- fdrtool(res77$stat,statistic="normal",plot=T)

FDR.res77$param[1,"sd"]
#new estimated null model variance is 0.7777072771, lower than 1 (theoretical one)

#add the new BH-adjusted p-values to the results frame 
res77[,"padj"] <- p.adjust(FDR.res77$pval, method="BH")

#plot the histogram of the "Correct" pvalues 
hist(FDR.res77$pval,col="royalblue4", main="77 vs Anc, correct null model", xlab="CORRECTED p values")
 
#test how many of the genes are now differentially expressed with this new null model
###now there are 770! 770 more than 0! 
table(res77[,"padj"] < 0.1)

#plot the MA plot
plotMA(res77)

sigGenes77 <- rownames(subset(res77,padj<0.1))

genesSig77 <- as.data.frame(subset(genesNoAneu, GENEID %in% sigGenes77))

summary(res77)

``` 

How many adjusted p-values were less than 0.1?

```{r sumRes01}
#Holly_GC_Anc vs Holly_2
sum(res$padj < 0.1, na.rm=TRUE)
``` 

The *results* function contains a number of arguments to
customize the results table which is generated. You can read about
these arguments by looking up `?results`.
Note that the *results* function automatically performs independent
filtering based on the mean of normalized counts for each gene,
optimizing the number of genes which will have an adjusted *p* value
below a given FDR cutoff, `alpha`.
Independent filtering is further discussed [below](#indfilt).
By default the argument `alpha` is set to $0.1$.  If the adjusted *p*
value cutoff will be a value other than $0.1$, `alpha` should be set to
that value:

```{r resAlpha05}
#Holly_GC_Anc vs Holly_2
res05 <- results(dds, alpha=0.05, contrast=c("condition","Holly_Anc","Holly_2"))
summary(res05)
sum(res05$padj < 0.05, na.rm=TRUE)
``` 

<a name="IHW"/>

### Independent hypothesis weighting

A generalization of the idea of *p* value filtering is to *weight*
hypotheses to optimize power. A Bioconductor
package, [IHW](http://bioconductor.org/packages/IHW), is available
that implements the method of *Independent Hypothesis Weighting*
[@Ignatiadis2016].  Here we show the use of *IHW* for *p* value
adjustment of DESeq2 results.  For more details, please see the
vignette of the [IHW](http://bioconductor.org/packages/IHW)
package. The *IHW* result object is stored in the metadata.

**Note:** If the results of independent hypothesis weighting are used
in published research, please cite:

> Ignatiadis, N., Klaus, B., Zaugg, J.B., Huber, W. (2016)
> Data-driven hypothesis weighting increases detection power in genome-scale multiple testing.
> *Nature Methods*, **13**:7.
> [10.1038/nmeth.3885](http://dx.doi.org/10.1038/nmeth.3885)

```{r IHW}
#source("https://bioconductor.org/biocLite.R")
#biocLite("IHW")
library("IHW")
resIWH <- results(dds, filterFun=ihw, contrast=c("condition","Holly_Anc","Holly_2"))
resIHW <- ihw(res, filter="baseMean",alpha=0.1, adjustment_type="BH")
summary(resIHW)
sum(resIHW$padj < 0.1, na.rm=TRUE)
metadata(resIHW)$ihwResult

res21IWH <- results(dds, filterFun=ihw, contrast=c("condition","Holly_21","Holly_Anc"))
res21IHW <- ihw(res21, filter="baseMean",alpha=0.1, adjustment_type="BH")
summary(res21IHW)
sum(res21IHW$padj < 0.1, na.rm=TRUE)
metadata(res21IHW)$ihwResult
``` 

For advanced users, note that all the values calculated by the DESeq2 
package are stored in the *DESeqDataSet* object or the *DESeqResults*
object, and access to these values is discussed [below](#access).

## Exploring and exporting results

### MA-plot

In DESeq2, the function *plotMA* shows the log2
fold changes attributable to a given variable over the mean of
normalized counts for all the samples in the *DESeqDataSet*.
Points will be colored red if the adjusted *p* value is less than 0.1.
Points which fall out of the window are plotted as open triangles pointing 
either up or down.

```{r MA}
plotMA(res, ylim=c(-2,2))

```

It is more useful visualize the MA-plot for the shrunken log2 fold
changes, which remove the noise associated with log2 fold changes from
low count genes without requiring arbitrary filtering thresholds.

```{r shrunkMA}
plotMA(resLFC, ylim=c(-2,2))
```

After calling *plotMA*, one can use the function
*identify* to interactively detect the row number of
individual genes by clicking on the plot. One can then recover
the gene identifiers by saving the resulting indices:

```{r MAidentify, eval=FALSE}
{plotMA(resLFC, ylim=c(-2,2))
idx <- identify(res$baseMean, res$log2FoldChange)}
rownames(res)[idx]
``` 

<a name="shrink"/>

### Alternative shrinkage estimators

The moderated log fold changes proposed by @Love2014 use a normal
prior distribution, centered on zero and with a scale that is fit to
the data. The shrunken log fold changes are useful for ranking and
visualization, without the need for arbitrary filters on low count
genes. The normal prior can sometimes produce too strong of
shrinkage for certain datasets. In DESeq2 version 1.18, we include two
additional adaptive shrinkage estimators, available via the `type`
argument of `lfcShrink`. For more details, see `?lfcShrink`

The options for `type` are:

* `normal` is the the original DESeq2 shrinkage estimator, an adaptive
  Normal distribution as prior. This is currently the default,
  although the default will likely change to `apeglm` in the 
  October 2018 release given `apeglm`'s superior performance.
* `apeglm` is the adaptive t prior shrinkage estimator from the 
  [apeglm](http://bioconductor.org/packages/apeglm) package [@Zhu2018].
* `ashr` is the adaptive shrinkage estimator from the
  [ashr](https://github.com/stephens999/ashr) package [@Stephens2016].
  Here DESeq2 uses the ashr option to fit a mixture of Normal distributions to
  form the prior, with `method="shrinkage"`.

If the shrinkage estimator `apeglm` is used in published research, please cite:

> Zhu, A., Ibrahim, J.G., Love, M.I. (2018)
> Heavy-tailed prior distributions for sequence count data: 
> removing the noise and preserving large differences. 
> *bioRxiv*. [10.1101/303255](https://doi.org/10.1101/303255)

If the shrinkage estimator `ashr` is used in published research, please cite:

> Stephens, M. (2016) 
> False discovery rates: a new deal. *Biostatistics*, **18**:2.
> [10.1093/biostatistics/kxw041](https://doi.org/10.1093/biostatistics/kxw041)

In the LFC shrinkage code above, we specified
`coef="condition_treated_vs_untreated"`. We can also just specify the
coefficient by the order that it appears in `resultsNames(dds)`, in
this case `coef=2`. For more details explaining how the shrinkage
estimators differ, and what kinds of designs, contrasts and output is
provided by each, see the [extended section on shrinkage estimators](#moreshrink).

```{r warning=FALSE}

#library(REBayes)
resultsNames(dds)
# because we are interested in treated vs untreated, we set 'coef=2'
resNorm <- lfcShrink(dds, coef=6, type="normal")
resAsh <- lfcShrink(dds, coef=6, type="ashr")

res21Norm <- lfcShrink(dds, coef=7, type="normal")
res21Ash <- lfcShrink(dds, coef=7, type="ashr")
```

```{r fig.width=8, fig.height=3}
par(mfrow=c(1,3), mar=c(4,4,2,1))
xlim <- c(1,1e5); ylim <- c(-3,3)
plotMA(resLFC, xlim=xlim, ylim=ylim, main="apeglm")
sum(resLFC$padj < 0.1, na.rm=TRUE)
plotMA(resNorm, xlim=xlim, ylim=ylim, main="normal")
sum(resNorm$padj < 0.1, na.rm=TRUE)
plotMA(resAsh, xlim=xlim, ylim=ylim, main="ashr")
sum(resAsh$padj < 0.1, na.rm=TRUE)

plotMA(res21LFC, xlim=xlim, ylim=ylim, main="apeglm")
sum(res21LFC$padj < 0.1, na.rm=TRUE)
plotMA(res21Norm, xlim=xlim, ylim=ylim, main="normal")
sum(res21Norm$padj < 0.1, na.rm=TRUE)
plotMA(res21Ash, xlim=xlim, ylim=ylim, main="ashr")
sum(res21Ash$padj < 0.1, na.rm=TRUE)
```

**Note:** We have sped up the `apeglm` method so it takes roughly
about the same amount of time as `normal`, e.g. ~5 seconds for the
`pasilla` dataset of ~10,000 genes and 7 samples.
If fast shrinkage estimation of LFC is needed,
*but the posterior standard deviation is not needed*, 
setting `apeMethod="nbinomC"` will produce a ~10x speedup,
but the `lfcSE` column will be returned with `NA`. 
A variant of this fast method, `apeMethod="nbinomC*"` includes random starts.

**Note:** If there is unwanted variation present in the data (e.g. batch
effects) it is always recommend to correct for this, which can be
accommodated in DESeq2 by including in the design any known batch
variables or by using functions/packages such as 
`svaseq` in [sva](http://bioconductor.org/packages/sva) [@Leek2014] or 
the `RUV` functions in [RUVSeq](http://bioconductor.org/packages/RUVSeq) [@Risso2014]
to estimate variables that capture the unwanted variation.
In addition, the ashr developers have a 
[specific method](https://github.com/dcgerard/vicar) 
for accounting for unwanted variation in combination with ashr [@Gerard2017].

### Plot counts 

It can also be useful to examine the counts of reads for a single gene
across the groups. A simple function for making this
plot is *plotCounts*, which normalizes counts by sequencing depth
and adds a pseudocount of 1/2 to allow for log scale plotting.
The counts are grouped by the variables in `intgroup`, where
more than one variable can be specified. Here we specify the gene
which had the smallest *p* value from the results table created
above. You can select the gene to plot by rowname or by numeric index.

```{r plotCounts}
plotCounts(dds, gene=which.min(res$padj), intgroup="condition")
``` 

For customized plotting, an argument `returnData` specifies
that the function should only return a *data.frame* for
plotting with *ggplot*.

```{r plotCountsAdv}
d <- plotCounts(dds, gene=which.min(res$padj), intgroup="condition", 
                returnData=TRUE)
library("ggplot2")
ggplot(d, aes(x=condition, y=count)) + 
  geom_point(position=position_jitter(w=0.1,h=0)) + 
  scale_y_log10(breaks=c(25,100,400))
``` 

### More information on results columns 

Information about which variables and tests were used can be found by calling
the function *mcols* on the results object.

```{r metadata}
mcols(res)$description
```

For a particular gene, a log2 fold change of -1 for
`condition treated vs untreated` means that the treatment
induces a multiplicative change in observed gene expression level of
$2^{-1} = 0.5$ compared to the untreated condition. If the variable of
interest is continuous-valued, then the reported log2 fold change is
per unit of change of that variable.

<a name="pvaluesNA"/>

**Note on p-values set to NA**: some values in the results table
can be set to `NA` for one of the following reasons:

* If within a row, all samples have zero counts, 
  the `baseMean` column will be zero, and the
  log2 fold change estimates, *p* value and adjusted *p* value
  will all be set to `NA`.
* If a row contains a sample with an extreme count outlier
  then the *p* value and adjusted *p* value will be set to `NA`.
  These outlier counts are detected by Cook's distance. Customization
  of this outlier filtering and description of functionality for 
  replacement of outlier counts and refitting is described 
  [below](#outlier)
* If a row is filtered by automatic independent filtering, 
  for having a low mean normalized count, then only the adjusted *p*
  value will be set to `NA`. 
  Description and customization of independent filtering is 
  described [below](#indfilt)

### Rich visualization and reporting of results

**ReportingTools.** An HTML report of the results with plots and sortable/filterable columns
can be generated using the [ReportingTools](http://bioconductor.org/packages/ReportingTools) package
on a *DESeqDataSet* that has been processed by the *DESeq* function.
For a code example, see the *RNA-seq differential expression* vignette at
the [ReportingTools](http://bioconductor.org/packages/ReportingTools) page, or the manual page for the 
*publish* method for the *DESeqDataSet* class.
``` {r reportingTools}
#source("https://bioconductor.org/biocLite.R")
#        biocLite("ReportingTools")
library(ReportingTools)


#conditions <- c(rep("case",3), rep("control", 3))
# mockRna.dse <- DESeqDataSetFromMatrix(countData = mockRnaSeqData,
# colData = as.data.frame(conditions), design = ~ conditions)
# colData(mockRna.dse)$conditions <- factor(colData(mockRna.dse)$conditions, levels=c("control", "case")) > ## Get a DESeqDataSet object
# mockRna.dse <- DESeq(mockRna.dse)        
        
des2Report <- HTMLReport(shortName = 'RNAseq_analysis_with_DESeq2',
title = 'RNA-seq analysis of differential expression using DESeq2',
reportDirectory = "./reports")
publish(dds,des2Report, pvalueCutoff=0.05,
    annotation.db="org.Hs.eg.db", factor = colData(dds)$conditions,
     reportDir="./reports")
finish(des2Report)
```


**regionReport.** An HTML and PDF summary of the results with plots
can also be generated using the [regionReport](http://bioconductor.org/packages/regionReport) package.
The *DESeq2Report* function should be run on a 
*DESeqDataSet* that has been processed by the *DESeq* function.
For more details see the manual page for *DESeq2Report* 
and an example vignette in the [regionReport](http://bioconductor.org/packages/regionReport) package.

``` {r regionReport}
#source("https://bioconductor.org/biocLite.R")
 #       biocLite("regionReport")
library(regionReport)
#create a directory where the report will be stored
dir.create('DESeq2-example', showWarnings = FALSE, recursive = TRUE)                

library('ggplot2')

## Create the HTML report
report <- DESeq2Report(ddsNoAneuInNorm, project = 'DESeq2 HTML report',
    intgroup = c('condition'), outdir = 'DESeq2-example',
    output = 'index', theme = theme_bw())   


##this one looks like it would be really useful, does a lot of the stuff for you! 
counts <- counts(dds)
colnames(counts)
dim(counts)
nonzero_row <- counts[rowSums(counts) > 0 ,]
dim(nonzero_row)

# histogram of p values for 21 vs anc
res21.df <- as.data.frame(res21)

## Sort results by adjusted p-values
ord <- order(res21.df$padj, decreasing = FALSE)
res21.df <- res21.df[ord, ]
res21.df <- cbind(data.frame(Feature = rownames(res21.df)), res21.df)
rownames(res21.df) <- NULL
ggplot(res21.df[!is.na(res21.df$pvalue), ], aes(x = pvalue)) +
    geom_histogram(alpha=.5, position='identity', bins = 50) +
    labs(title='Histogram of unadjusted p-values') +
    xlab('Unadjusted p-values') +
    xlim(c(0, 1.0005)) 

```


**Glimma.** Interactive visualization of DESeq2 output, 
including MA-plots (also called MD-plot) can be generated using the
[Glimma](http://bioconductor.org/packages/Glimma) package. See the manual page for *glMDPlot.DESeqResults*.



**pcaExplorer.** Interactive visualization of DESeq2 output,
including PCA plots, boxplots of counts and other useful summaries can be
generated using the [pcaExplorer](http://bioconductor.org/packages/pcaExplorer) package.
See the *Launching the application* section of the package vignette.

```{r pcaExplorer}
#source("https://bioconductor.org/biocLite.R")
#biocLite("pcaExplorer")
library(pcaExplorer)
pcaExplorer(dds = ddsNoAneuInNorm)
##This one also seems pretty awesome!!! 
```

### Exporting results to CSV files

A plain-text file of the results can be exported using the 
base R functions *write.csv* or *write.delim*. 
We suggest using a descriptive file name indicating the variable
and levels which were tested.

```{r export, eval=FALSE}
write.csv(as.data.frame(resOrdered), 
          file="2_vs_Anc_results.csv")
```

Exporting only the results which pass an adjusted *p* value
threshold can be accomplished with the *subset* function,
followed by the *write.csv* function.

```{r subset}
resSig <- subset(resOrdered, padj < 0.1)
resSig
``` 

## Multi-factor designs

Experiments with more than one factor influencing the counts can be
analyzed using design formula that include the additional variables.
In fact, DESeq2 can analyze any possible experimental design that can
be expressed with fixed effects terms (multiple factors, designs with
interactions, designs with continuous variables, splines, and so on
are all possible).

By adding variables to the design, one can control for additional variation
in the counts. For example, if the condition samples are balanced
across experimental batches, by including the `batch` factor to the
design, one can increase the sensitivity for finding differences due
to `condition`. There are multiple ways to analyze experiments when the
additional variables are of interest and not just controlling factors 
(see [section on interactions](#interactions)).

The data in the [pasilla](http://bioconductor.org/packages/pasilla) 
package have a condition of interest 
(the column `condition`), as well as information on the type of sequencing 
which was performed (the column `type`), as we can see below:

```{r multifactor}
colData(dds)
```

We create a copy of the *DESeqDataSet*, so that we can rerun
the analysis using a multi-factor design.

```{r copyMultifactor}
ddsMF <- dds
```

We change the levels of `type` so it only contains letters (numbers, underscore and
period are also allowed in design factor levels). Be careful when
changing level names to use the same order as the current levels.

```{r fixLevels}
levels(ddsMF$type)
levels(ddsMF$type) <- sub("-.*", "", levels(ddsMF$type))
levels(ddsMF$type)
```

We can account for the different types of sequencing, and get a clearer picture
of the differences attributable to the treatment.  As `condition` is the
variable of interest, we put it at the end of the formula. Thus the *results*
function will by default pull the `condition` results unless 
`contrast` or `name` arguments are specified. 

Then we can re-run *DESeq*:

```{r replaceDesign}
design(ddsMF) <- formula(~ type + condition)
ddsMF <- DESeq(ddsMF)
```

Again, we access the results using the *results* function.

```{r multiResults}
resMF <- results(ddsMF)
head(resMF)
```

It is also possible to retrieve the log2 fold changes, *p* values and adjusted
*p* values of variables other than the last one in the design. 
While in this case, `type` is not biologically interesting as it
indicates differences across sequencing protocol, for other
hypothetical designs, such as  `~genotype + condition +
genotype:condition`, 
we may actually be interested in the difference in baseline expression
across genotype, which is not the last variable in the design.

In any case, the `contrast` argument of 
the function *results* takes a character vector of length three:
the name of the variable, the name of the factor level for the numerator
of the log2 ratio, and the name of the factor level for the denominator.
The `contrast` argument can also take other forms, as
described in the help page for *results* and [below](#contrasts)

```{r multiTypeResults}
resMFType <- results(ddsMF,
                     contrast=c("type", "single", "paired"))
head(resMFType)
```

If the variable is continuous or an interaction term
(see [section on interactions](#interactions))
then the results can be extracted using the `name` argument to *results*,
where the name is one of elements returned by `resultsNames(dds)`.

<a name="transform"/>

# Data transformations and visualization 

## Count data transformations

In order to test for differential expression, we operate on raw counts
and use discrete distributions as described in the previous section on
differential expression.
However for other downstream analyses --
e.g. for visualization or clustering -- it might be useful 
to work with transformed versions of the count data. 

Maybe the most obvious choice of transformation is the logarithm.
Since count values for a gene can be zero in some
conditions (and non-zero in others), some advocate the use of
*pseudocounts*, i.e. transformations of the form:

$$ y = \log_2(n + n_0) $$

where *n* represents the count values and $n_0$ is a positive constant.

In this section, we discuss two alternative
approaches that offer more theoretical justification and a rational way
of choosing parameters equivalent to $n_0$ above.
One makes use of the concept of variance stabilizing
transformations (VST) [@Tibshirani1988; @sagmb2003; @Anders:2010:GB],
and the other is the *regularized logarithm* or *rlog*, which
incorporates a prior on the sample differences [@Love2014].
Both transformations produce transformed data on the log2 scale
which has been normalized with respect to library size or other
normalization factors.

The point of these two transformations, the VST and the *rlog*,
is to remove the dependence of the variance on the mean,
particularly the high variance of the logarithm of count data when the
mean is low. Both VST and *rlog* use the experiment-wide trend
of variance over mean, in order to transform the data to remove the
experiment-wide trend. Note that we do not require or
desire that all the genes have *exactly* the same variance after
transformation. Indeed, in a figure below, you will see
that after the transformations the genes with the same mean do not
have exactly the same standard deviations, but that the
experiment-wide trend has flattened. It is those genes with row
variance above the trend which will allow us to cluster samples into
interesting groups.

**Note on running time:** if you have many samples (e.g. 100s),
the *rlog* function might take too long, and so the *vst* function
will be a faster choice. 
The rlog and VST have similar properties, but the rlog requires
fitting a shrinkage term for each sample and each gene which takes
time. See the DESeq2 paper for more discussion on the differences
[@Love2014].

### Blind dispersion estimation

The two functions, *vst* and *rlog* have an argument
`blind`, for whether the transformation should be blind to the
sample information specified by the design formula. When
`blind` equals `TRUE` (the default), the functions
will re-estimate the dispersions using only an intercept.
This setting should be used in order to compare
samples in a manner wholly unbiased by the information about
experimental groups, for example to perform sample QA (quality
assurance) as demonstrated below.

However, blind dispersion estimation is not the appropriate choice if
one expects that many or the majority of genes (rows) will have large
differences in counts which are explainable by the experimental design,
and one wishes to transform the data for downstream analysis. In this
case, using blind dispersion estimation will lead to large estimates
of dispersion, as it attributes differences due to experimental design
as unwanted *noise*, and will result in overly shrinking the transformed
values towards each other. 
By setting `blind` to `FALSE`, the dispersions
already estimated will be used to perform transformations, or if not
present, they will be estimated using the current design formula. Note
that only the fitted dispersion estimates from mean-dispersion trend
line are used in the transformation (the global dependence of
dispersion on mean for the entire experiment).
So setting `blind` to `FALSE` is still for the most
part not using the information about which samples were in which
experimental group in applying the transformation.

### Extracting transformed values

These transformation functions return an object of class *DESeqTransform*
which is a subclass of *RangedSummarizedExperiment*. 
For ~20 samples, running on a newly created `DESeqDataSet`,
*rlog* may take 30 seconds, while *vst* takes less than 1 second.
The running times are shorter when using `blind=FALSE` and
if the function *DESeq* has already been run, because then
it is not necessary to re-estimate the dispersion values.
The *assay* function is used to extract the matrix of normalized values.

```{r rlogAndVST}
vsd <- vst(dds, blind=FALSE)
rld <- rlog(dds, blind=FALSE)
head(assay(vsd), 3)
```

### Variance stabilizing transformation

Above, we used a parametric fit for the dispersion. In this case, the
closed-form expression for the variance stabilizing transformation is
used by the *vst* function. If a local fit is used (option
`fitType="locfit"` to *estimateDispersions*) a numerical integration
is used instead. The transformed data should be approximated variance
stabilized and also includes correction for size factors or
normalization factors. The transformed data is on the log2 scale for
large counts.

### Regularized log transformation

The function *rlog*, stands for *regularized log*,
transforming the original count data to the log2 scale by fitting a
model with a term for each sample and a prior distribution on the
coefficients which is estimated from the data. This is the same kind
of shrinkage (sometimes referred to as regularization, or moderation)
of log fold changes used by the *DESeq* and
*nbinomWaldTest*. The resulting data contains elements defined as:

$$ \log_2(q_{ij}) = \beta_{i0} + \beta_{ij} $$

where $q_{ij}$ is a parameter proportional to the expected true
concentration of fragments for gene *i* and sample *j* (see
formula [below](#theory)), $\beta_{i0}$ is an intercept which does not
undergo shrinkage, and $\beta_{ij}$ is the sample-specific effect
which is shrunk toward zero based on the dispersion-mean trend over
the entire dataset. The trend typically captures high dispersions for
low counts, and therefore these genes exhibit higher shrinkage from
the *rlog*.

Note that, as $q_{ij}$ represents the part of the mean value
$\mu_{ij}$ after the size factor $s_j$ has been divided out, it is
clear that the rlog transformation inherently accounts for differences
in sequencing depth. Without priors, this design matrix would lead to
a non-unique solution, however the addition of a prior on
non-intercept betas allows for a unique solution to be found. 

### Effects of transformations on the variance

The figure below plots the standard deviation of the transformed data,
across samples, against the mean, using the shifted logarithm
transformation, the regularized log transformation and the variance
stabilizing transformation.  The shifted logarithm has elevated
standard deviation in the lower count range, and the regularized log
to a lesser extent, while for the variance stabilized data the
standard deviation is roughly constant along the whole dynamic range.

Note that the vertical axis in such plots is the square root of the
variance over all samples, so including the variance due to the
experimental conditions.  While a flat curve of the square root of
variance over the mean may seem like the goal of such transformations,
this may be unreasonable in the case of datasets with many true
differences due to the experimental conditions.

```{r meansd}
# this gives log2(n + 1)
ntd <- normTransform(dds)
#source("https://bioconductor.org/biocLite.R")
 #       biocLite("vsn")
library("vsn")
meanSdPlot(assay(ntd))
meanSdPlot(assay(vsd))
meanSdPlot(assay(rld))
```

## Data quality assessment by sample clustering and visualization

Data quality assessment and quality control (i.e. the removal of
insufficiently good data) are essential steps of any data
analysis. These steps should typically be performed 
very early in the analysis of a new data set,
preceding or in parallel to the differential expression testing.

We define the term *quality* as *fitness for purpose*.
Our purpose is the detection of differentially expressed genes, and we
are looking in particular for samples whose experimental treatment
suffered from an anormality that renders the data points obtained from
these particular samples detrimental to our purpose.

### Heatmap of the count matrix

To explore a count matrix, it is often instructive to look at it as a
heatmap. Below we show how to produce such a heatmap for various
transformations of the data. 

```{r heatmap}
library("pheatmap")
select <- order(rowMeans(counts(dds,normalized=TRUE)),
                decreasing=TRUE)[1:20]
df <- as.data.frame(colData(dds)["condition"])
pheatmap(assay(ntd)[select,], cluster_rows=FALSE, show_rownames=FALSE,
         cluster_cols=FALSE, annotation_col=df)
pheatmap(assay(vsd)[select,], cluster_rows=FALSE, show_rownames=FALSE,
         cluster_cols=FALSE, annotation_col=df)
pheatmap(assay(rld)[select,], cluster_rows=FALSE, show_rownames=FALSE,
         cluster_cols=FALSE, annotation_col=df)
```

### Heatmap of the sample-to-sample distances

Another use of the transformed data is sample clustering. Here, we
apply the *dist* function to the transpose of the transformed count
matrix to get sample-to-sample distances.

```{r sampleClust}
sampleDists <- dist(t(assay(vsd)))
```

A heatmap of this distance matrix gives us an overview over
similarities and dissimilarities between samples.  We have to provide
a hierarchical clustering `hc` to the heatmap function based on the
sample distances, or else the heatmap function would calculate a
clustering based on the distances between the rows/columns of the
distance matrix.

```{r figHeatmapSamples, fig.height=4, fig.width=6}
library("RColorBrewer")
sampleDistMatrix <- as.matrix(sampleDists)
rownames(sampleDistMatrix) <- paste(vsd$condition, vsd$type, sep="-")

colnames(sampleDistMatrix) <- NULL
colors <- colorRampPalette( rev(brewer.pal(29, "Blues")) )(255)
pheatmap(sampleDistMatrix,
         clustering_distance_rows=sampleDists,
         clustering_distance_cols=sampleDists,
         col=colors)
```

### Principal component plot of the samples

Related to the distance matrix is the PCA plot, which shows 
the samples in the 2D plane spanned by their first two principal
components. This type of plot is useful for visualizing the overall
effect of experimental covariates and batch effects.

```{r figPCA}
plotPCA(vsd, intgroup=c("condition"))
```

It is also possible to customize the PCA plot using the
*ggplot* function.

```{r figPCA2}
#this doesnt work on parathyroid data because it only has one PC (condition)
dds$run <- as.factor(dds$run)

pcaData <- plotPCA(vsd, intgroup=c("condition","run"), returnData=TRUE)
percentVar <- round(100 * attr(pcaData, "percentVar"))

ggplot(pcaData, aes(PC1, PC2, color=condition, shape=dds$run)) +
  geom_point(size=3) +
  xlab(paste0("PC1: ",percentVar[1],"% variance")) +
  ylab(paste0("PC2: ",percentVar[2],"% variance")) + 
  coord_fixed()
```

# Variations to the standard workflow

## Wald test individual steps 

The function *DESeq* runs the following functions in order:

```{r WaldTest, eval=FALSE}
dds <- estimateSizeFactors(dds)
dds <- estimateDispersions(dds)
dds <- nbinomWaldTest(dds)
```

<a name="contrasts"/>

## Contrasts 

A contrast is a linear combination of estimated log2 fold changes,
which can be used to test if differences between groups are equal to
zero.  The simplest use case for contrasts is an experimental design
containing a factor with three levels, say A, B and C.  Contrasts
enable the user to generate results for all 3 possible differences:
log2 fold change of B vs A, of C vs A, and of C vs B.
The `contrast` argument of *results* function is
used to extract test results of log2 fold changes of interest, for example:

```{r simpleContrast, eval=FALSE}
results(dds, contrast=c("condition","Holly_Anc","Holly_2"))
``` 

Log2 fold changes can also be added and subtracted by providing a
`list` to the `contrast` argument which has two elements:
the names of the log2 fold changes to add, and the names of the log2
fold changes to subtract. The names used in the list should come from
`resultsNames(dds)`. Alternatively, a numeric vector of the
length of `resultsNames(dds)` can be provided, for manually
specifying the linear combination of terms.  Demonstrations of the use
of contrasts for various designs can be found in the examples section
of the help page `?results`. The mathematical formula that is used to
generate the contrasts can be found [below](#theory).

<a name="interactions"/>

## Interactions 

Interaction terms can be added to the design formula, in order to
test, for example, if the log2 fold change attributable to a given
condition is *different* based on another factor, for example if the
condition effect differs across genotype.

**Initial note:** 
Many users begin to add interaction terms to the design formula, when
in fact a much simpler approach would give all the results tables that
are desired. We will explain this approach first, because it is much simpler to perform.
If the comparisons of interest are, for example, the effect
of a condition for different sets of samples, a simpler approach than
adding interaction terms explicitly to the design formula is to
perform the following steps:

* combine the factors of interest into a single factor with all
  combinations of the original factors 
* change the design to include just this factor, e.g. ~ group

Using this design is similar to adding an interaction term, 
in that it models multiple condition effects which
can be easily extracted with *results*.
Suppose we have two factors `genotype` (with values I, II, and III) 
and `condition` (with values A and B), and we want to extract 
the condition effect specifically for each genotype. We could use the
following approach to obtain, e.g. the condition effect for genotype I: 

```{r combineFactors, eval=FALSE}
dds$group <- factor(paste0(dds$run, dds$condition))
design(dds) <- ~ group
dds$condition <- relevel(dds$condition, ref="Holly_Anc")
dds <- DESeq(dds)
resultsNames(dds)
results(dds, contrast=c("group", "Holly_Anc", "Holly_2"))
```

**Adding interactions to the design:** 
The following two plots diagram genotype-specific
condition effects, which could be modeled with interaction terms by
using a design of `~genotype + condition + genotype:condition`.

In the first plot (Gene 1), note that the condition effect
is consistent across genotypes. Although condition A has a different
baseline for I,II, and III, the condition effect is a log2 fold
change of about 2 for each genotype.  Using a model with an
interaction term `genotype:condition`, the interaction terms for
genotype II and genotype III will be nearly 0.

Here, the y-axis represents log2(n+1), and each
group has 20 samples (black dots). A red line connects the mean of the
groups within each genotype. 

```{r interFig, echo=FALSE, results="hide", fig.height=3}
npg <- 20
mu <- 2^c(8,10,9,11,10,12)
cond <- rep(rep(c("A","B"),each=npg),3)
geno <- rep(c("I","II","III"),each=2*npg)
table(cond, geno)
counts <- rnbinom(6*npg, mu=rep(mu,each=npg), size=1/.01)
d <- data.frame(log2c=log2(counts+1), cond, geno)
library("ggplot2")
plotit <- function(d, title) {
  ggplot(d, aes(x=cond, y=log2c, group=geno)) + 
    geom_jitter(size=1.5, position = position_jitter(width=.15)) +
    facet_wrap(~ geno) + 
    stat_summary(fun.y=mean, geom="line", colour="red", size=0.8) + 
    xlab("condition") + ylab("log2(counts+1)") + ggtitle(title)
}
plotit(d, "Gene 1") + ylim(7,13)
lm(log2c ~ cond + geno + geno:cond, data=d)
``` 

In the second plot
(Gene 2), we can see that the condition effect is not consistent
across genotype. Here the main condition effect (the effect for the
reference genotype I) is again 2. However, this time the interaction
terms will be around 1 for genotype II and -4 for genotype III. This
is because the condition effect is higher by 1 for genotype II
compared to genotype I, and lower by 4 for genotype III compared to
genotype I.  The condition effect for genotype II (or III) is
obtained by adding the main condition effect and the interaction
term for that genotype.  Such a plot can be made using the
*plotCounts* function as shown above.

```{r interFig2, echo=FALSE, results="hide", fig.height=3}
mu[4] <- 2^12
mu[6] <- 2^8
counts <- rnbinom(6*npg, mu=rep(mu,each=npg), size=1/.01)
d2 <- data.frame(log2c=log2(counts + 1), cond, geno)
plotit(d2, "Gene 2") + ylim(7,13)
lm(log2c ~ cond + geno + geno:cond, data=d2)
``` 

Now we will continue to explain the use of interactions in order to
test for *differences* in condition effects. We continue with
the example of condition effects across three genotypes (I, II, and III).

The key point to remember about designs with interaction terms is
that, unlike for a design `~genotype + condition`, where the condition
effect represents the 
*overall* effect controlling for differences due to genotype, by adding
`genotype:condition`, the main condition effect only
represents the effect of condition for the *reference level* of
genotype (I, or whichever level was defined by the user as the
reference level). The interaction terms `genotypeII.conditionB`
and `genotypeIII.conditionB` give the *difference*
between the condition effect for a given genotype and the condition
effect for the reference genotype. 

This genotype-condition interaction example is examined in further
detail in Example 3 in the help page for *results*, which
can be found by typing `?results`. In particular, we show how to
test for differences in the condition effect across genotype, and we
show how to obtain the condition effect for non-reference genotypes.

## Time-series experiments

There are a number of ways to analyze time-series experiments,
depending on the biological question of interest. In order to test for
any differences over multiple time points, once can use a design
including the time factor, and then test using the likelihood ratio
test as described in the following section, where the time factor is
removed in the reduced formula. For a control and treatment time
series, one can use a design formula containing the condition factor,
the time factor, and the interaction of the two. In this case, using
the likelihood ratio test with a reduced model which does not contain
the interaction terms will test whether the condition induces a change
in gene expression at any time point after the reference level time point
(time 0). An example of the later analysis is provided in our
[RNA-seq workflow](http://www.bioconductor.org/help/workflows/rnaseqGene).

## Likelihood ratio test 

DESeq2 offers two kinds of hypothesis tests: the Wald test, where
we use the estimated standard error of a log2 fold change to test if it is
equal to zero, and the likelihood ratio test (LRT). The LRT examines
two models for the counts, a *full* model with a certain number
of terms and a *reduced* model, in which some of the terms of the
*full* model are removed. The test determines if the increased
likelihood of the data using the extra terms in the *full* model
is more than expected if those extra terms are truly zero.

The LRT is therefore useful for testing multiple
terms at once, for example testing 3 or more levels of a factor at once,
or all interactions between two variables. 
The LRT for count data is conceptually similar to an analysis of variance (ANOVA)
calculation in linear regression, except that in the case of the Negative
Binomial GLM, we use an analysis of deviance (ANODEV), where the
*deviance* captures the difference in likelihood between a full
and a reduced model.

The likelihood ratio test can be performed by specifying `test="LRT"`
when using the *DESeq* function, and
providing a reduced design formula, e.g. one in which a
number of terms from `design(dds)` are removed.
The degrees of freedom for the test is obtained from the difference
between the number of parameters in the two models. 
A simple likelihood ratio test, if the full design was
`~condition` would look like:

```{r simpleLRT, eval=FALSE}
dds <- DESeq(dds, test="LRT", reduced=~1)
res <- results(dds)
``` 

If the full design contained other variables, 
such as a batch variable, e.g. `~batch + condition`
then the likelihood ratio test would look like:

```{r simpleLRT2, eval=FALSE}
dds <- DESeq(dds, test="LRT", reduced=~batch)
res <- results(dds)
``` 

<a name="moreshrink"/>

## Extended section on shrinkage estimators

Here we extend the [discussion of shrinkage estimators](#shrink).
To repeat, the current default method in `lfcShrink` is `normal`,
although it will likely change in the October 2018 release to
`apeglm`, as this method has improved performance relative to the
original *DESeq2* estimator, as does `ashr` in some of our benchmarks.
Below is a summary table of differences between methods available in `lfcShrink`
via the `type` argument (and for further technical reference on use of
arguments please see `?lfcShrink`):

| method:  | `normal`^1^  | `apeglm`^2^ | `ashr`^3^ |
|---|:-:|:-:|:-:|
| Good for ranking by LFC |  |  |  |
| Preserves size of large LFC |  |  |  |
| Can compute *s-values* [@Stephens2016] |  |  |  |
| Allows use of `coef` |  |  |  |
| Allows use of `lfcThreshold` |  |  |  |
| Allows use of `contrast` |  |  |  |
| Can shrink interaction terms |  |  |  |

**References:** 1. @Love2014; 2. @Zhu2018; 3. @Stephens2016

Beginning with the first row, all shrinkage methods provided by
DESeq2 are good for ranking genes by "effect size", that is the log2
fold change (LFC) across groups, or associated with an interaction term. It
is useful to contrast ranking by effect size with ranking by a
p-value or adjusted p-value associated with a null hypothesis: while
increasing the number of samples will tend to decrease the associated
p-value for a gene that is differentially expressed, the estimated
effect size or LFC becomes more precise. Also, a gene can have a small
p-value although the change in expression is not great, as long as the
standard error associated with the estimated LFC is small.

The next two rows point out that `apeglm` and `ashr` shrinkage methods
help to preserve the size of large LFC, and can be used
to compute *s-values*. These properties are related. As noted in the
[previous section](#altshrink), the original DESeq2 shrinkage
estimator used a Normal distribution, with a scale that adapts to the
spread of the observed LFCs. Because the tails of the Normal
distribution become thin relatively quickly, it was important when we
designed the method that the prior scaling is sensitive to the very
largest observed LFCs. As you can read in the DESeq2 paper, under the
section, "*Empirical prior estimate*", we used the top 5% of the LFCs by
absolute value to set the scale of the Normal prior (we later added
weighting the quantile by precision). `ashr`, published
in 2016, and `apeglm` use wide-tailed priors to avoid shrinking large
LFCs. While a typical RNA-seq experiment may have many LFCs between -1
and 1, we might consider a LFC of >4 to be very large, as they
represent 16-fold increases or decreases in expression. `ashr` and
`apeglm` can adapt to the scale of the entirety of LFCs, while not
over-shrinking the few largest LFCs. The potential for over-shrinking
LFC is also why DESeq2's shrinkage estimator is not recommended for
designs with interaction terms.

What are *s-values*? This quantity proposed by @Stephens2016 gives the 
estimated rate of *false sign* among genes with equal or smaller s-value.
@Stephens2016 points out they are analogous to the *q*-value of
@Storey2003. 
The s-value has a desirable property relative to the adjusted
p-value or *q*-value, in that it does not require supposing there to
be a set of null genes with LFC = 0 (the most commonly used null
hypothesis). Therefore, it can be benchmarked
by comparing estimated LFC and s-value to the "true LFC" in a setting
where this can be reasonably defined. For these estimated
probabilities to be accurate, the scale of the prior needs to match
the scale of the distribution of effect sizes, and so the original
DESeq2 shrinkage method is not really compatible with computing s-values.

The last four rows explain differences in whether coefficients or
contrasts can have shrinkage applied by the various methods. All three
methods can use `coef` with either the name or numeric index from
`resultsNames(dds)` to specify which coefficient to shrink. `normal`
and `apeglm` also allow for a positive `lfcThreshold` to be specified,
in which case, they will return p-values and adjusted p-values or
s-values for the LFC being greater in absolute value than the
threshold (see [this section](#thresh) for `normal`). For `apeglm`,
setting a threshold means that the s-values will give the "false sign
or small" rate (FSOS) among genes with equal or small s-value.
We found FSOS to be a useful description for when the LFC is either
the wrong sign or less than the threshold distance from 0.

```{r apeThresh}
resApeT <- lfcShrink(dds, coef=2, type="apeglm", lfcThreshold=1)
{plotMA(resApeT, ylim=c(-3,3), cex=.8)
abline(h=c(-1,1), col="dodgerblue", lwd=2)}
resultsNames(dds)
res21ApeT <- lfcShrink(dds, coef=7, type="apeglm", lfcThreshold=1)
{plotMA(res21ApeT, ylim=c(-3,3), cex=.8)
abline(h=c(-1,1), col="dodgerblue", lwd=2)}
```

Finally, `normal` and `ashr` can be used with arbitrary specified
`contrast` because `normal` shrinks multiple coefficients
simultaneously (`apeglm` does not), and because `ashr` does not
estimate a vector of coefficients but models estimated coefficients
and their standard errors from upstream methods (here, DESeq2's MLE).
Although `apeglm` cannot be used with `contrast`, we note that many
designs can be easily rearranged such that what was a contrast becomes
its own coefficient. In this case, the dispersion does not have to be
estimated again, as the designs are equivalent, up to the meaning of
the coefficients. Instead, one need only run `nbinomWaldTest` to
re-estimate MLE coefficients -- these are necessary for `apeglm` --
and then run `lfcShrink` specifying the coefficient of interest in
`resultsNames(dds)`.

We give some examples below of producing equivalent designs for use
with `coef`. We show how the coefficients change with `model.matrix`,
but the user would, for example, either change the levels of
`dds$condition` or replace the design using `design(dds)<-`, then run
`nbinomWaldTest` followed by `lfcShrink`.

Three groups:

```{r}
condition <- factor(rep(c("A","B","C"),each=2))
model.matrix(~ condition)
# to compare C vs B, make B the reference level,
# and select the last coefficient
condition <- relevel(condition, "B")
model.matrix(~ condition)
```

Three groups, compare condition effects:

```{r}
grp <- factor(rep(1:3,each=4))
cnd <- factor(rep(rep(c("A","B"),each=2),3))
model.matrix(~ grp + cnd + grp:cnd)
# to compare condition effect in group 3 vs 2,
# make group 2 the reference level,
# and select the last coefficient
grp <- relevel(grp, "2")
model.matrix(~ grp + cnd + grp:cnd)
```

Two groups, two individuals per group, compare within-individual
condition effects:

```{r}
grp <- factor(rep(1:2,each=4))
ind <- factor(rep(rep(1:2,each=2),2))
cnd <- factor(rep(c("A","B"),4))
model.matrix(~grp + grp:ind + grp:cnd)
# to compare condition effect across group,
# add a main effect for 'cnd',
# and select the last coefficient
model.matrix(~grp + cnd + grp:ind + grp:cnd)
```

<a name="singlecell"/>

## Recommendations for single-cell analysis

We have a few recommendations for best use of DESeq2 for single-cell
datasets, which have been published in a recent manuscript [@Berge2018].
These recommendations may also be useful for modeling other data that
better fits to a Zero-Inflated Negative Binomial (ZINB) distribution,
rather than a Negative Binomial (NB).

* One can use the
  [zinbwave](https://bioconductor.org/packages/zinbwave) package
  to directly model the zero inflation of the counts, and take account
  of these in the DESeq2 model. There is example code for combining
  *zinbwave* and *DESeq2* package functions in the *zinbwave*
  vignette. We also have an example of ZINB-WaVE + DESeq2 integration using
  the [splatter](https://bioconductor.org/packages/splatter) package
  for simulation at the 
  [zinbwave-deseq2](https://github.com/mikelove/zinbwave-deseq2) GitHub repository.
* It is best to use `test="LRT"` for significance testing when working with
  single-cell data, over the Wald test. This has been observed across
  multiple single-cell benchmarks.
* It is recommended to set the following `DESeq` arguments: 
  `sfType="poscounts"`, 
  `useT=TRUE`,
  `minmu=1e-6`, and
  `minReplicatesForReplace=Inf`.
  
<a name="outlier"/>

## Approach to count outliers 

RNA-seq data sometimes contain isolated instances of very large counts
that are apparently unrelated to the experimental or study design, and
which may be considered outliers. There are many reasons why outliers
can arise, including rare technical or experimental artifacts, read
mapping problems in the case of genetically differing samples, and
genuine, but rare biological events. In many cases, users appear
primarily interested in genes that show a consistent behavior, and
this is the reason why by default, genes that are affected by such
outliers are set aside by DESeq2, or if there are sufficient samples,
outlier counts are replaced for model fitting.  These two behaviors
are described below.

The *DESeq* function calculates, for every gene and for every sample,
a diagnostic test for outliers called *Cook's distance*. Cook's distance 
is a measure of how much a single sample is influencing the fitted 
coefficients for a gene, and a large value of Cook's distance is 
intended to indicate an outlier count. 
The Cook's distances are stored as a matrix available in 
`assays(dds)[["cooks"]]`.

The *results* function automatically flags genes which contain a 
Cook's distance above a cutoff for samples which have 3 or more replicates. 
The *p* values and adjusted *p* values for these genes are set to `NA`. 
At least 3 replicates are required for flagging, as it is difficult to judge
which sample might be an outlier with only 2 replicates.
This filtering can be turned off with `results(dds, cooksCutoff=FALSE)`.

With many degrees of freedom -- i.\,e., many more samples than number of parameters to 
be estimated -- it is undesirable to remove entire genes from the analysis
just because their data include a single count outlier. When there
are 7 or more replicates for a given sample, the *DESeq*
function will automatically replace counts with large Cook's distance 
with the trimmed mean over all samples, scaled up by the size factor or 
normalization factor for that sample. This approach is conservative, 
it will not lead to false positives, as it replaces
the outlier value with the value predicted by the null hypothesis.
This outlier replacement only occurs when there are 7 or more
replicates, and can be turned off with 
`DESeq(dds, minReplicatesForReplace=Inf)`.

The default Cook's distance cutoff for the two behaviors described above
depends on the sample size and number of parameters
to be estimated. The default is to use the 99% quantile of the 
F(p,m-p) distribution (with *p* the number of parameters including the 
intercept and *m* number of samples).
The default for gene flagging can be modified using the `cooksCutoff` 
argument to the *results* function. 
For outlier replacement, *DESeq* preserves the original counts in
`counts(dds)` saving the replacement counts as a matrix named
`replaceCounts` in `assays(dds)`.
Note that with continuous variables in the design, outlier detection
and replacement is not automatically performed, as our 
current methods involve a robust estimation of within-group variance
which does not extend easily to continuous covariates. However, users
can examine the Cook's distances in `assays(dds)[["cooks"]]`, in
order to perform manual visualization and filtering if necessary.

**Note on many outliers:** if there are very many outliers (e.g. many
hundreds or thousands) reported by `summary(res)`, one might consider
further exploration to see if a single sample or a few samples should
be removed due to low quality.  The automatic outlier
filtering/replacement is most useful in situations which the number of
outliers is limited. When there are thousands of reported outliers, it
might make more sense to turn off the outlier filtering/replacement
(*DESeq* with `minReplicatesForReplace=Inf` and *results* with
`cooksCutoff=FALSE`) and perform manual inspection: First it would be
advantageous to make a PCA plot as described above to spot individual
sample outliers; Second, one can make a boxplot of the Cook's
distances to see if one sample is consistently higher than others
(here this is not the case):

```{r boxplotCooks}
assays(dds)[["cooks"]]
par(mar=c(8,5,2,2))

boxplot(log10(assays(dds)[["cooks"]]), range=0, las=2)
```

## Dispersion plot and fitting alternatives

Plotting the dispersion estimates is a useful diagnostic. The dispersion
plot below is typical, with the final estimates shrunk
from the gene-wise estimates towards the fitted estimates. Some gene-wise
estimates are flagged as outliers and not shrunk towards the fitted value,
(this outlier detection is described in the manual page for *estimateDispersionsMAP*).
The amount of shrinkage can be more or less than seen here, depending 
on the sample size, the number of coefficients, the row mean
and the variability of the gene-wise estimates.

```{r dispFit}
plotDispEsts(dds)
```

### Local or mean dispersion fit

A local smoothed dispersion fit is automatically substitited in the case that
the parametric curve doesn't fit the observed dispersion mean relationship.
This can be prespecified by providing the argument
`fitType="local"` to either *DESeq* or *estimateDispersions*.
Additionally, using the mean of gene-wise disperion estimates as the
fitted value can be specified by providing the argument `fitType="mean"`. 

### Supply a custom dispersion fit

Any fitted values can be provided during dispersion estimation, using
the lower-level functions described in the manual page for
*estimateDispersionsGeneEst*. In the code chunk below, we
store the gene-wise estimates which were already calculated and saved 
in the metadata column `dispGeneEst`. Then we calculate the
median value of the dispersion estimates above a threshold, and save
these values as the fitted dispersions, using the replacement function
for *dispersionFunction*. In the last line, the function
*estimateDispersionsMAP*, uses the 
fitted dispersions to generate maximum *a posteriori* (MAP)
estimates of dispersion. 

```{r dispFitCustom}
ddsCustom <- dds
useForMedian <- mcols(ddsCustom)$dispGeneEst > 1e-7
medianDisp <- median(mcols(ddsCustom)$dispGeneEst[useForMedian],
                     na.rm=TRUE)
dispersionFunction(ddsCustom) <- function(mu) medianDisp
ddsCustom <- estimateDispersionsMAP(ddsCustom)
```

<a name="indfilt"/>

## Independent filtering of results

The *results* function of the DESeq2 package performs independent
filtering by default using the mean of normalized counts as a filter
statistic.  A threshold on the filter statistic is found which
optimizes the number of adjusted *p* values lower than a significance
level `alpha` (we use the standard variable name for significance
level, though it is unrelated to the dispersion parameter $\alpha$).
The theory behind independent filtering is discussed in greater detail
[below](#indfilttheory). The adjusted *p* values for the genes
which do not pass the filter threshold are set to `NA`.

The default independent filtering is performed using the *filtered_p*
function of the [genefilter](http://bioconductor.org/packages/genefilter) package, and all of the
arguments of *filtered_p* can be passed to the *results* function.
The filter threshold value and the number of rejections at each
quantile of the filter statistic are available as metadata of the
object returned by *results*.

For example, we can visualize the optimization by plotting the
`filterNumRej` attribute of the results object. The *results* function
maximizes the number of rejections (adjusted *p* value less than a
significance level), over the quantiles of a filter statistic (the
mean of normalized counts). The threshold chosen (vertical line) is
the lowest quantile of the filter for which the number of rejections
is within 1 residual standard deviation to the peak of a curve fit to
the number of rejections over the filter quantiles:

```{r filtByMean}
metadata(res)$alpha
metadata(res)$filterThreshold
{plot(metadata(res)$filterNumRej, 
     type="b", ylab="number of rejections",
     xlab="quantiles of filter")
lines(metadata(res)$lo.fit, col="red")
abline(v=metadata(res)$filterTheta)}
```

Independent filtering can be turned off by setting 
`independentFiltering` to `FALSE`.

```{r noFilt}
resNoFilt <- results(dds, independentFiltering=FALSE)
addmargins(table(filtering=(res$padj < .1),
                 noFiltering=(resNoFilt$padj < .1)))
``` 

<a name="thresh"/>

## Tests of log2 fold change above or below a threshold

It is also possible to provide thresholds for constructing
Wald tests of significance. Two arguments to the *results*
function allow for threshold-based Wald tests: `lfcThreshold`,
which takes a numeric of a non-negative threshold value, 
and `altHypothesis`, which specifies the kind of test.
Note that the *alternative hypothesis* is specified by the user, 
i.e. those genes which the user is interested in finding, and the test 
provides *p* values for the null hypothesis, the complement of the set 
defined by the alternative. The `altHypothesis` argument can take one 
of the following four values, where $\beta$ is the log2 fold change
specified by the `name` argument, and $x$ is the `lfcThreshold`.

* `greaterAbs` - $|\beta| > x$ - tests are two-tailed
* `lessAbs` - $|\beta| < x$ - *p* values are the maximum of the upper and lower tests
* `greater` - $\beta > x$
* `less` - $\beta < -x$

The four possible values of `altHypothesis` are demonstrated
in the following code and visually by MA-plots in the following figures.

```{r lfcThresh}
par(mfrow=c(2,2),mar=c(2,2,1,1))
ylim <- c(-2.5,2.5)
resGA <- results(dds, lfcThreshold=.5, altHypothesis="greaterAbs", test="Wald")
resLA <- results(dds, lfcThreshold=.5, altHypothesis="lessAbs", test="Wald")
resG <- results(dds, lfcThreshold=.5, altHypothesis="greater", test="Wald")
resL <- results(dds, lfcThreshold=.5, altHypothesis="less", test="Wald")
drawLines <- function() abline(h=c(-.5,.5),col="dodgerblue",lwd=2)
plotMA(resGA, ylim=ylim); drawLines()
plotMA(resLA, ylim=ylim); drawLines()
plotMA(resG, ylim=ylim); drawLines()
plotMA(resL, ylim=ylim); drawLines()
```

<a name="access"/>

## Access to all calculated values

All row-wise calculated values (intermediate dispersion calculations,
coefficients, standard errors, etc.) are stored in the *DESeqDataSet* 
object, e.g. `dds` in this vignette. These values are accessible 
by calling *mcols* on `dds`. 
Descriptions of the columns are accessible by two calls to 
*mcols*. Note that the call to `substr` below is only for display
purposes.

```{r mcols}
mcols(dds,use.names=TRUE)[1:4,1:4]
substr(names(mcols(dds)),1,10) 
colInfo <- as.data.frame(mcols(mcols(dds), use.names=TRUE)[1:21,])
```

The mean values $\mu_{ij} = s_j q_{ij}$ and the Cook's distances for each gene and
sample are stored as matrices in the assays slot:

```{r muAndCooks}
head(assays(dds)[["mu"]])
head(assays(dds)[["cooks"]])
``` 

The dispersions $\alpha_i$ can be accessed with the
*dispersions* function.

```{r dispersions}
head(dispersions(dds))
head(mcols(dds)$dispersion)
``` 

The size factors $s_j$ are accessible via *sizeFactors*:

```{r sizefactors}
sizeFactors(dds)
``` 

For advanced users, we also include a convenience function *coef* for 
extracting the matrix $[\beta_{ir}]$ for all genes *i* and
model coefficients $r$.
This function can also return a matrix of standard errors, see `?coef`.
The columns of this matrix correspond to the effects returned by *resultsNames*.
Note that the *results* function is best for building 
results tables with *p* values and adjusted *p* values.

```{r coef}
head(coef(dds))
``` 

The beta prior variance $\sigma_r^2$ is stored as an attribute of the
*DESeqDataSet*: 

```{r betaPriorVar}
attr(dds, "betaPriorVar")
``` 

General information about the prior used for log fold change shrinkage
is also stored in a slot of the *DESeqResults* object. This would
also contain information about what other packages were used
for log2 fold change shrinkage.

```{r priorInfo}
priorInfo(resLFC)
priorInfo(resNorm)
priorInfo(resAsh)
```

The dispersion prior variance $\sigma_d^2$ is stored as an
attribute of the dispersion function:

```{r dispPriorVar}
dispersionFunction(dds)
attr(dispersionFunction(dds), "dispPriorVar")
``` 

The version of DESeq2 which was used to construct the
*DESeqDataSet* object, or the version used when
*DESeq* was run, is stored here:

```{r versionNum}
metadata(dds)[["version"]]
``` 

## Sample-/gene-dependent normalization factors 

In some experiments, there might be gene-dependent dependencies
which vary across samples. For instance, GC-content bias or length
bias might vary across samples coming from different labs or
processed at different times. We use the terms *normalization factors*
for a gene x sample matrix, and *size factors* for a
single number per sample.  Incorporating normalization factors,
the mean parameter $\mu_{ij}$ becomes:

$$ \mu_{ij} = NF_{ij} q_{ij} $$

with normalization factor matrix *NF* having the same dimensions
as the counts matrix *K*. This matrix can be incorporated as shown
below. We recommend providing a matrix with row-wise geometric means of 1, 
so that the mean of normalized counts for a gene is close to the mean
of the unnormalized counts.
This can be accomplished by dividing out the current row geometric means.

```{r normFactors, eval=FALSE}
normFactors <- normFactors/exp(rowMeans(log(normFactors)))
normalizationFactors(dds) <- normFactors
```

These steps then replace *estimateSizeFactors* which occurs within the
*DESeq* function. The *DESeq* function will look for pre-existing
normalization factors and use these in the place of size factors
(and a message will be printed confirming this).

The methods provided by the
[cqn](http://bioconductor.org/packages/cqn) or 
[EDASeq](http://bioconductor.org/packages/EDASeq) packages
can help correct for GC or length biases. They both describe in their
vignettes how to create matrices which can be used by DESeq2.
From the formula above, we see that normalization factors should be on
the scale of the counts, like size factors, and unlike offsets which
are typically on the scale of the predictors (i.e. the logarithmic scale for
the negative binomial GLM). At the time of writing, the transformation
from the matrices provided by these packages should be:

```{r offsetTransform, eval=FALSE}
cqnOffset <- cqnObject$glm.offset
cqnNormFactors <- exp(cqnOffset)
EDASeqNormFactors <- exp(-1 * EDASeqOffset)
```

## "Model matrix not full rank"

While most experimental designs run easily using design formula, some
design formulas can cause problems and result in the *DESeq*
function returning an error with the text: "the model matrix is not
full rank, so the model cannot be fit as specified."  There are two
main reasons for this problem: either one or more columns in the model
matrix are linear combinations of other columns, or there are levels
of factors or combinations of levels of multiple factors which are
missing samples. We address these two problems below and discuss
possible solutions:

### Linear combinations

The simplest case is the linear combination, or linear dependency
problem, when two variables contain exactly the same information, such
as in the following sample table. The software cannot fit an effect
for `batch` and `condition`, because they produce
identical columns in the model matrix. This is also referred to as
*perfect confounding*. A unique solution of coefficients (the $\beta_i$ in
the formula [below](#theory)) is not possible.

```{r lineardep, echo=FALSE}
DataFrame(batch=factor(c(1,1,2,2)), condition=factor(c("A","A","B","B")))
``` 

Another situation which will cause problems is when the variables are
not identical, but one variable can be formed by the combination of
other factor levels. In the following example, the effect of batch 2
vs 1 cannot be fit because it is identical to a column in the model
matrix which represents the condition C vs A effect.

```{r lineardep2, echo=FALSE}
DataFrame(batch=factor(c(1,1,1,1,2,2)), condition=factor(c("A","A","B","B","C","C")))
``` 

In both of these cases above, the batch effect cannot be fit and must
be removed from the model formula. There is just no way to tell apart
the condition effects and the batch effects. The options are either to assume
there is no batch effect (which we know is highly unlikely given the
literature on batch effects in sequencing datasets) or to repeat the
experiment and properly balance the conditions across batches.
A balanced design would look like:

```{r lineardep3, echo=FALSE}
DataFrame(batch=factor(c(1,1,1,2,2,2)), condition=factor(c("A","B","C","A","B","C")))
``` 

<a name="nested-indiv"/>

### Group-specific condition effects, individuals nested within groups

Finally, there is a case where we *can* in fact perform inference, but
we may need to re-arrange terms to do so. Consider an experiment with
grouped individuals, where we seek to test the group-specific effect
of a condition or treatment, while controlling for individual
effects. The individuals are nested within the groups: an individual
can only be in one of the groups, although each individual has one or
more observations across condition.

An example of such an experiment is below:

```{r groupeffect}
coldata <- DataFrame(grp=factor(rep(c("X","Y"),each=6)),
                       ind=factor(rep(1:6,each=2)),
                      cnd=factor(rep(c("A","B"),6)))
coldata
```

Note that individual (`ind`) is a *factor* not a numeric. This is very
important. 

To make R display all the rows, we can do:

```{r}
as.data.frame(coldata)
```

We have two groups of samples X and Y, each with three distinct
individuals (labeled here 1-6). For each individual, we have
conditions A and B (for example, this could be control and treated).

This design can be analyzed by DESeq2 but requires a bit of
refactoring in order to fit the model terms. Here we will use a trick
described in the [edgeR](http://bioconductor.org/packages/edgeR) user
guide, from the section 
*Comparisons Both Between and Within Subjects*.  If we try to
analyze with a formula such as, `~ ind + grp*cnd`, we will
obtain an error, because the effect for group is a linear combination
of the individuals.

However, the following steps allow for an analysis of group-specific
condition effects, while controlling for differences in individual.
For object construction, you can use a simple design, such as 
`~ ind + cnd`, as
long as you remember to replace it before running *DESeq*.
Then add a column `ind.n` which distinguishes the
individuals nested within a group. Here, we add this column to
coldata, but in practice you would add this column to `dds`.

```{r groupeffect2}
coldata$ind.n <- factor(rep(rep(1:3,each=2),2))
as.data.frame(coldata)
``` 

Now we can reassign our *DESeqDataSet* a design of
`~ grp + grp:ind.n + grp:cnd`, before we call
*DESeq*. This new design will result in the following model
matrix: 

```{r groupeffect3}
model.matrix(~ grp + grp:ind.n + grp:cnd, coldata)
``` 

Note that, if you have unbalanced numbers of individuals in the two
groups, you will have zeros for some of the interactions between `grp`
and `ind.n`. You can remove these columns manually from the model
matrix and pass the corrected model matrix to the `full` argument of
the *DESeq* function. See example code in the next section.

Above, the terms `grpX.cndB` and `grpY.cndB` give the
group-specific condition effects, in other words, the condition B vs A
effect for group X samples, and likewise for group Y samples. These
terms control for all of the six individual effects.
These group-specific condition effects can be extracted using
*results* with the `name` argument. 

Furthermore, `grpX.cndB` and `grpY.cndB` can be contrasted using the
`contrast` argument, in order to test if the condition effect is
different across group: 

```{r groupeffect4, eval=FALSE}
results(dds, contrast=list("grpY.cndB","grpX.cndB"))
``` 

### Levels without samples

The base R function for creating model matrices will produce a column
of zeros if a level is missing from a factor or a combination of
levels is missing from an interaction of factors. The solution to the
first case is to call *droplevels* on the column, which will
remove levels without samples. This was shown in the beginning of this
vignette.

The second case is also solvable, by manually editing the model
matrix, and then providing this to *DESeq*. Here we
construct an example dataset to illustrate:

```{r missingcombo}
group <- factor(rep(1:3,each=6))
condition <- factor(rep(rep(c("A","B","C"),each=2),3))
d <- DataFrame(group, condition)[-c(17,18),]
as.data.frame(d)
``` 

Note that if we try to estimate all interaction terms, we introduce a
column with all zeros, as there are no condition C samples for group
3. (Here, *unname* is used to display the matrix concisely.)

```{r missingcombo2}
m1 <- model.matrix(~ condition*group, d)
colnames(m1)
unname(m1)
all.zero <- apply(m1, 2, function(x) all(x==0))
all.zero
``` 

We can remove this column like so:

```{r missingcombo3}
idx <- which(all.zero)
m1 <- m1[,-idx]
unname(m1)
``` 

Now this matrix `m1` can be provided to the `full`
argument of *DESeq*.  For a likelihood ratio test of
interactions, a model matrix using a reduced design such as
`~ condition + group` can be given to the `reduced`
argument. Wald tests can also be generated instead of the likelihood
ratio test, but for user-supplied model matrices, the argument
`betaPrior` must be set to `FALSE`.

<a name="theory"/>

# Theory behind DESeq2

## The DESeq2 model 

The DESeq2 model and all the steps taken in the software
are described in detail in our publication [@Love2014],
and we include the formula and descriptions in this section as well.
The differential expression analysis in DESeq2 uses a generalized
linear model of the form:

$$ K_{ij} \sim \textrm{NB}(\mu_{ij}, \alpha_i) $$

$$ \mu_{ij} = s_j q_{ij} $$

$$ \log_2(q_{ij}) = x_{j.} \beta_i $$

where counts $K_{ij}$ for gene *i*, sample *j* are modeled using
a negative binomial distribution with fitted mean $\mu_{ij}$
and a gene-specific dispersion parameter $\alpha_i$.
The fitted mean is composed of a sample-specific size factor
$s_j$ and a parameter $q_{ij}$ 
proportional to the expected true concentration of fragments for sample *j*.
The coefficients $\beta_i$ give the log2 fold changes for gene *i* for each 
column of the model matrix $X$. 
Note that the model can be generalized to use sample- and
gene-dependent normalization factors $s_{ij}$. 

The dispersion parameter $\alpha_i$ defines the relationship between
the variance of the observed count and its mean value. In other
words, how far do we expected the observed count will be from the
mean value, which depends both on the size factor $s_j$ and the
covariate-dependent part $q_{ij}$ as defined above.

$$ \textrm{Var}(K_{ij}) = E[ (K_{ij} - \mu_{ij})^2 ] = \mu_{ij} + \alpha_i \mu_{ij}^2 $$

An option in DESeq2 is to provide maximum *a posteriori*
estimates of the log2 fold changes in $\beta_i$ after incorporating a 
zero-centered Normal prior (`betaPrior`). While previously,
these moderated, or shrunken, estimates were generated by
*DESeq* or *nbinomWaldTest* functions, they are now produced by the
*lfcShrink* function.
Dispersions are estimated using expected mean values from the maximum
likelihood estimate of log2 fold changes, and optimizing the Cox-Reid 
adjusted profile likelihood, as first implemented for RNA-seq data in
[edgeR](http://bioconductor.org/packages/edgeR) 
[@CR,edgeR_GLM]. The steps performed by the *DESeq* function are
documented in its manual page `?DESeq`; briefly, they are:

1) estimation of size factors $s_j$ by *estimateSizeFactors*
2) estimation of dispersion $\alpha_i$ by *estimateDispersions*
3) negative binomial GLM fitting for $\beta_i$ and Wald statistics by 
*nbinomWaldTest*

For access to all the values calculated during these steps, see the
section [above](#access).

## Changes compared to DESeq

The main changes in the package *DESeq2*, compared to the (older)
version *DESeq*, are as follows: 

* *RangedSummarizedExperiment* is used as the superclass for storage of input data,
  intermediate calculations and results.
* Optional, maximum *a posteriori* estimation of GLM coefficients
  incorporating a zero-centered Normal prior with variance estimated
  from data (equivalent to Tikhonov/ridge regularization). This
  adjustment has little effect on genes with high counts, yet it helps
  to moderate the otherwise large variance in log2 fold change
  estimates for genes with low counts or highly variable counts.
  These estimates are now provided by the *lfcShrink* function.
* Maximum *a posteriori* estimation of dispersion replaces the
  `sharingMode` options `fit-only` or `maximum` of the previous version
  of the package. This is similar to the dispersion estimation methods of DSS [@Wu2012New].
* All estimation and inference is based on the generalized linear model, which
  includes the two condition case (previously the *exact test* was used).
* The Wald test for significance of GLM coefficients is provided as the default
  inference method, with the likelihood ratio test of the previous version still available.
* It is possible to provide a matrix of sample-/gene-dependent
  normalization factors.
* Automatic independent filtering on the mean of normalized counts.
* Automatic outlier detection and handling.

<a name="changes"/>

## Methods changes since the 2014 DESeq2 paper

* In version 1.18 (November 2017), we add two 
  [alternative shrinkage estimators](#alternative-shrinkage-estimators),
  which can be used via `lfcShrink`: an estimator using a t prior from
  the apeglm packages, and an estimator with a fitted mixture of
  normals prior from the ashr package.
* In version 1.16 (November 2016), the log2 fold change 
  shrinkage is no longer default for the *DESeq* and *nbinomWaldTest*
  functions, by setting the defaults of these to `betaPrior=FALSE`,
  and by introducing a separate function *lfcShrink*, which performs
  log2 fold change shrinkage for visualization and ranking of genes.
  While for the majority of bulk RNA-seq experiments, the LFC
  shrinkage did not affect statistical testing, DESeq2 has become used
  as an inference engine by a wider community, and certain sequencing
  datasets show better performance with the testing separated from the
  use of the LFC prior. Also, the separation of LFC shrinkage to a separate
  function `lfcShrink` allows for easier methods development of
  alternative effect size estimators.
* A small change to the independent filtering routine: instead
  of taking the quantile of the filter (the mean of normalized counts) which
  directly *maximizes* the number of rejections, the threshold chosen is 
  the lowest quantile of the filter for which the
  number of rejections is close to the peak of a curve fit
  to the number of rejections over the filter quantiles.
  ``Close to'' is defined as within 1 residual standard deviation.
  This change was introduced in version 1.10 (October 2015).
* For the calculation of the beta prior variance, instead of
  matching the empirical quantile to the quantile of a Normal
  distribution, DESeq2 now uses the weighted quantile function
  of the Hmisc package. The weighting is described in the
  manual page for *nbinomWaldTest*.  The weights are the
  inverse of the expected variance of log counts (as used in the
  diagonals of the matrix $W$ in the GLM). The effect of the change
  is that the estimated prior variance is robust against noisy
  estimates of log fold change from genes with very small
  counts. This change was introduced in version 1.6 (October 2014).

For a list of all changes since version 1.0.0, see the `NEWS` file
included in the package.

## Count outlier detection 

DESeq2 relies on the negative binomial distribution to make
estimates and perform statistical inference on differences.  While the
negative binomial is versatile in having a mean and dispersion
parameter, extreme counts in individual samples might not fit well to
the negative binomial. For this reason, we perform automatic detection
of count outliers. We use Cook's distance, which is a measure of how
much the fitted coefficients would change if an individual sample were
removed [@Cook1977Detection]. For more on the implementation of 
Cook's distance see the manual page
for the *results* function. Below we plot the maximum value of
Cook's distance for each row over the rank of the test statistic 
to justify its use as a filtering criterion.

```{r cooksPlot}
W <- res21$stat
maxCooks <- apply(assays(dds)[["cooks"]],1,max)
idx <- !is.na(W)
plot(rank(W[idx]), maxCooks[idx], xlab="rank of Wald statistic", 
     ylab="maximum Cook's distance per gene",
     ylim=c(0,5), cex=.4, col=rgb(0,0,0,.3))
m <- ncol(dds)
p <- 3
abline(h=qf(.99, p, m - p))
``` 

## Contrasts 

Contrasts can be calculated for a *DESeqDataSet* object for which
the GLM coefficients have already been fit using the Wald test steps
(*DESeq* with `test="Wald"` or using *nbinomWaldTest*).
The vector of coefficients $\beta$ is left multiplied by the contrast vector $c$
to form the numerator of the test statistic. The denominator is formed by multiplying
the covariance matrix $\Sigma$ for the coefficients on either side by the 
contrast vector $c$. The square root of this product is an estimate
of the standard error for the contrast. The contrast statistic is then compared
to a Normal distribution as are the Wald statistics for the DESeq2
package.

$$ W = \frac{c^t \beta}{\sqrt{c^t \Sigma c}} $$

## Expanded model matrices 

For the specific combination of `lfcShrink` with the type `normal` and
using `contrast`, DESeq2 uses *expanded model matrices* to produce
shrunken log2 fold change estimates where the shrinkage is independent
of the choice of reference level. In all other cases, DESeq2 uses
standard model matrices, as produced by `model.matrix`.  The expanded
model matrices differ from the standard model matrices, in that they
have an indicator column (and therefore a coefficient) for each level
of factors in the design formula in addition to an intercept. This is
described in the DESeq2 paper. Using type `normal` with `coef` uses
standard model matrices, as does the `apeglm` shrinkage estimator.

<a name="indfilttheory"/>

## Independent filtering and multiple testing 

### Filtering criteria 

The goal of independent filtering is to filter out those tests from
the procedure that have no, or little chance of showing significant
evidence, without even looking at their test statistic. Typically,
this results in increased detection power at the same experiment-wide
type I error. Here, we measure experiment-wide type I error in terms
of the false discovery rate.

A good choice for a filtering criterion is one that

1) is statistically independent from the test statistic under the null hypothesis,
2) is correlated with the test statistic under the alternative, and
3) does not notably change the dependence structure -- if there is any -- between 
   the tests that pass the filter, compared to the dependence structure
   between the tests before filtering.

The benefit from filtering relies on property (2), and we will explore
it further below. Its statistical validity relies on
property (1) -- which is simple to formally prove for many combinations
of filter criteria with test statistics -- and (3), which is less
easy to theoretically imply from first principles, but rarely a problem in practice.
We refer to [@Bourgon:2010:PNAS] for further discussion of this topic.

A simple filtering criterion readily available in the results object
is the mean of normalized counts irrespective of biological condition,
and so this is the criterion which is used automatically by the
*results* function to perform independent filtering.  Genes with very
low counts are not likely to see significant differences typically due
to high dispersion. For example, we can plot the $-\log_{10}$ *p*
values from all genes over the normalized mean counts:

```{r indFilt}
plot(res$baseMean+1, -log10(res$pvalue),
     log="x", xlab="mean of normalized counts",
     ylab=expression(-log[10](pvalue)),
     ylim=c(0,30),
     cex=.4, col=rgb(0,0,0,.3))
```

### Why does it work?

Consider the *p* value histogram below
It shows how the filtering ameliorates the multiple testing problem
-- and thus the severity of a multiple testing adjustment -- by
removing a background set of hypotheses whose *p* values are distributed
more or less uniformly in [0,1].

```{r histindepfilt}
use <- res$baseMean > metadata(res)$filterThreshold
h1 <- hist(res$pvalue[!use], breaks=0:50/50, plot=FALSE)
h2 <- hist(res$pvalue[use], breaks=0:50/50, plot=FALSE)
colori <- c(`do not pass`="khaki", `pass`="powderblue")
``` 

Histogram of p values for all tests.  The area shaded in blue
indicates the subset of those that pass the filtering, the area in
khaki those that do not pass: 

```{r fighistindepfilt}
barplot(height = rbind(h1$counts, h2$counts), beside = FALSE,
        col = colori, space = 0, main = "", ylab="frequency")
text(x = c(0, length(h1$counts)), y = 0, label = paste(c(0,1)),
     adj = c(0.5,1.7), xpd=NA)
legend("topright", fill=rev(colori), legend=rev(names(colori)))
```

<a name="FAQ"/>

# Frequently asked questions 

## How can I get support for DESeq2?

We welcome questions about our software, and want to
ensure that we eliminate issues if and when they appear. We have a few
requests to optimize the process:

* all questions should take place on the Bioconductor support
  site: <https://support.bioconductor.org>, which serves as a
  repository of questions and answers. This helps to save the
  developers' time in responding to similar questions. Make sure to
  tag your post with `deseq2`. It is often very helpful in addition 
  to describe the aim of your experiment.
* before posting, first search the Bioconductor support site
  mentioned above for past threads which might have answered your
  question.
* if you have a question about the behavior of a function, read
  the sections of the manual page for this function by typing a
  question mark and the function name, e.g. `?results`.  We
  spend a lot of time documenting individual functions and the exact
  steps that the software is performing.
* include all of your R code, especially the creation of the
  *DESeqDataSet* and the design formula.  Include complete
  warning or error messages, and conclude your message with the full
  output of `sessionInfo()`.
* if possible, include the output of
  `as.data.frame(colData(dds))`, so that we can have a sense
  of the experimental setup. If this contains confidential
  information, you can replace the levels of those factors using
  *levels()*.


## Why are some *p* values set to NA?
  
See the details [above](#pvaluesNA).

## How can I get unfiltered DESeq2 results?

Users can obtain unfiltered GLM results, i.e. without outlier removal
or independent filtering with the following call:

```{r vanillaDESeq, eval=FALSE}
dds <- DESeq(dds, minReplicatesForReplace=Inf)
res <- results(dds, cooksCutoff=FALSE, independentFiltering=FALSE)
```

In this case, the only *p* values set to `NA` are those from
genes with all counts equal to zero.

## How do I use VST or rlog data for differential testing?
  
The variance stabilizing and rlog transformations are provided for
applications other than differential testing, for example clustering
of samples or other machine learning applications. For differential
testing we recommend the *DESeq* function applied to raw
counts as outlined [above](#de).
  
## Can I use DESeq2 to analyze paired samples?

Yes, you should use a multi-factor design which includes the sample
information as a term in the design formula. This will account for 
differences between the samples while estimating the effect due to 
the condition. The condition of interest should go at the end of the 
design formula, e.g. `~ subject + condition`.

## If I have multiple groups, should I run all together or split into pairs of groups?

Typically, we recommend users to run samples from all groups together, and then
use the `contrast` argument of the *results* function
to extract comparisons of interest after fitting the model using *DESeq*.

The model fit by *DESeq* estimates a single dispersion
parameter for each gene, which defines how far we expect the observed
count for a sample will be from the mean value from the model 
given its size factor and its condition group. See the section
[above](#theory) and the DESeq2 paper for full details.
Having a single dispersion parameter for each gene is usually
sufficient for analyzing multi-group data, as the final dispersion value will
incorporate the within-group variability across all groups. 

However, for some datasets, exploratory data analysis (EDA) plots
could reveal that one or more groups has much 
higher within-group variability than the others. A simulated example
of such a set of samples is shown below.
This is case where, by comparing groups A and B separately --
subsetting a *DESeqDataSet* to only samples from those two
groups and then running *DESeq* on this subset -- will be
more sensitive than a model including all samples together.
It should be noted that such an extreme range of within-group
variability is not common, although it could arise if certain
treatments produce an extreme reaction (e.g. cell death).
Again, this can be easily detected from the EDA plots such as PCA
described in this vignette.

Here we diagram an extreme range of within-group variability with a
simulated dataset. Typically, it is recommended to run *DESeq* across
samples from all groups, for datasets with multiple groups. However,
this simulated dataset shows a case where it would be preferable to
compare groups A and B by creating a smaller dataset without the C
samples. Group C has much higher within-group variability, which would
inflate the per-gene dispersion estimate for groups A and B as well:

```{r varGroup, echo=FALSE}
set.seed(3)
dds1 <- makeExampleDESeqDataSet(n=1000,m=12,betaSD=.3,dispMeanRel=function(x) 0.01)
dds2 <- makeExampleDESeqDataSet(n=1000,m=12,
                                betaSD=.3,
                                interceptMean=mcols(dds1)$trueIntercept,
                                interceptSD=0,
                                dispMeanRel=function(x) 0.2)
dds2 <- dds2[,7:12]
dds2$condition <- rep("C",6)
mcols(dds2) <- NULL
dds12 <- cbind(dds1, dds2)
rld <- rlog(dds12, blind=FALSE, fitType="mean")
plotPCA(rld)
``` 

## Can I run DESeq2 to contrast the levels of many groups?

DESeq2 will work with any kind of design specified using the R
formula. We enourage users to consider exploratory data analysis such
as principal components analysis rather than performing statistical
testing of all pairs of many groups of samples. Statistical testing is
one of many ways of describing differences between samples.

As a speed concern with fitting very large models, 
note that each additional level of a factor in the
design formula adds another parameter to the GLM which is fit by
DESeq2. Users might consider first removing genes with very few
reads, as this will speed up the fitting procedure.

## Can I use DESeq2 to analyze a dataset without replicates?

If a *DESeqDataSet* is provided with an experimental design without replicates,
a warning is printed, that the samples are treated as replicates
for estimation of dispersion. This kind of analysis is
only useful for exploring the data, but will not provide the kind of
proper statistical inference on differences between groups.
Without biological replicates, it is not possible to estimate the biological
variability of each gene. 
More details can be found in the manual page for `?DESeq`.

## How can I include a continuous covariate in the design formula?

Continuous covariates can be included in the design formula in exactly
the same manner as factorial covariates, and then *results* for the
continuous covariate can be extracted by specifying `name`.
Continuous covariates might make sense in certain experiments, where a
constant fold change might be 
expected for each unit of the covariate.  However, in many cases, more
meaningful results can be obtained by cutting continuous covariates
into a factor defined over a small number of bins (e.g. 3-5).  In this
way, the average effect of each group is controlled for, regardless of
the trend over the continuous covariates.  In R, *numeric*
vectors can be converted into *factors* using the function *cut*.

## I ran a likelihood ratio test, but results() only gives me one comparison.

"... How do I get the *p* values for all of the variables/levels 
that were removed in the reduced design?"

This is explained in the help page for `?results` in the
section about likelihood ratio test p-values, but we will restate the
answer here. When one performs a likelihood ratio test, the *p* values and
the test statistic (the `stat` column) are values for the test
that removes all of the variables which are present in the full
design and not in the reduced design. This tests the null hypothesis
that all the coefficients from these variables and levels of these factors
are equal to zero.

The likelihood ratio test *p* values therefore
represent a test of *all the variables and all the levels of factors*
which are among these variables. However, the results table only has space for
one column of log fold change, so a single variable and a single
comparison is shown (among the potentially multiple log fold changes
which were tested in the likelihood ratio test). 
This is indicated at the top of the results table
with the text, e.g., log2 fold change (MLE): condition C vs A, followed
by, LRT p-value: '~ batch + condition' vs '~ batch'.
This indicates that the *p* value is for the likelihood ratio test of
*all the variables and all the levels*, while the log fold change is a single
comparison from among those variables and levels.
See the help page for *results* for more details.

## What are the exact steps performed by DESeq()?

See the manual page for *DESeq*, which links to the 
subfunctions which are called in order, where complete details are
listed. Also you can read the three steps listed in the 
[DESeq2 model](#theory) in this document.


## Is there an official Galaxy tool for DESeq2?

Yes. The repository for the DESeq2 tool is

<https://github.com/galaxyproject/tools-iuc/tree/master/tools/deseq2> 

and a link to its location in the Tool Shed is 

<https://toolshed.g2.bx.psu.edu/view/iuc/deseq2/d983d19fbbab>.

## I want to benchmark DESeq2 comparing to other DE tools.

One aspect which can cause problems for comparison is that, by default,
DESeq2 outputs `NA` values for adjusted *p* values based on 
independent filtering of genes which have low counts.
This is a way for the DESeq2 to give extra
information on why the adjusted *p* value for this gene is not small.
Additionally, *p* values can be set to `NA` based on extreme 
count outlier detection. These `NA` values should be considered
*negatives* for purposes of estimating sensitivity and specificity. The
easiest way to work with the adjusted *p* values in a benchmarking
context is probably to convert these `NA` values to 1:

```{r convertNA, eval=FALSE}
res$padj <- ifelse(is.na(res$padj), 1, res$padj)
``` 

## I have trouble installing DESeq2 on Ubuntu/Linux...

"*I try to install DESeq2, but I get an error trying to
install the R packages XML and/or RCurl:*"

`ERROR: configuration failed for package XML`

`ERROR: configuration failed for package RCurl`

You need to install the following devel versions of packages using
your standard package manager, e.g. `sudo apt-get install` or 
`sudo apt install`

* libxml2-dev
* libcurl4-openssl-dev

# Acknowledgments

We have benefited in the development of DESeq2 from the help and
feedback of many individuals, including but not limited to: 

The Bionconductor Core Team,
Alejandro Reyes, Andrzej Oles, Aleksandra Pekowska, Felix Klein,
Nikolaos Ignatiadis (IHW),
Anqi Zhu (apeglm),
Joseph Ibrahim (apeglm),
Vince Carey,
Owen Solberg,
Ruping Sun,
Devon Ryan, 
Steve Lianoglou, Jessica Larson, Christina Chaivorapol, Pan Du, Richard Bourgon,
Willem Talloen, 
Elin Videvall, Hanneke van Deutekom,
Todd Burwell, 
Jesse Rowley,
Igor Dolgalev,
Stephen Turner,
Ryan C Thompson,
Tyr Wiesner-Hanks,
Konrad Rudolph,
David Robinson,
Mingxiang Teng,
Mathias Lesche,
Sonali Arora,
Jordan Ramilowski,
Ian Dworkin,
Bjorn Gruning,
Ryan McMinds,
Paul Gordon,
Leonardo Collado Torres,
Enrico Ferrero,
Peter Langfelder,
Gavin Kelly,
Rob Patro,
Charlotte Soneson,
Koen Van den Berge,
Stephan Engelbrecht,
Nicolas Alcala.

# Session info

```{r sessionInfo}
sessionInfo()
```

# References

