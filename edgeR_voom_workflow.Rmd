---
title: "edgeR_voom_workflow"
author: "Holly"
date: "10/18/2017"
output: html_document
---
This workflow is following the protocol in Law et al 2016, F1000Research

First, we load our packages
```{r load_packages, include=TRUE}
#source("https://bioconductor.org/biocLite.R")
#biocLite("limma")
#source("https://bioconductor.org/biocLite.R")
#biocLite("edgeR")
#source("https://bioconductor.org/biocLite.R")
#biocLite("biomaRt")
#install.packages("dplyr")

library(limma)
library(Glimma)
library(edgeR)
library(dplyr)
library(RColorBrewer)
```

Then we read in our data
``` {r read data, include=TRUE}
raw <- read.delim("/Users/hollymcqueary/Dropbox/McQueary/Dosage-Compensation/Redo/September_2017/genes.count_table",row.names="tracking_id")
##add a grouping factor (for us this is the sample)
group <- as.factor(c("X112","X112","X112","X115","X115","X115","X117","X117","X117","X11","X11","X11","X123","X123","X123","X141","X141","X141","X152","X152","X152","X18","X18","X18","X1","X1","X1","X21","X21","X21","X29","X29","X29","X2","X2","X2","X31","X31","X31","X3","X3","X3","X49","X49","X49","X4","X4","X4","X50","X50","X50","X59","X59","X59","X5","X5","X5","X61","X61","X61","X66","X66","X66","X69","X69","X69","X6","X6","X6","X76","X76","X76","X77","X77","X77","X7","X7","X7","X8","X8","X8","X9","X9","X9","GCA","GCA","GCA","MAA","MAA","MAA"))
##convert the data into a DGEList-object (this uses edgeR)
x <- DGEList(counts=raw,group=group)
x$samples$group <- group
exp <- as.factor(rep(c("MA","GC","MA","GC","MA","GC","MA"),c(9,3,9,9,3,54,3)))
x$samples$exp <- exp
##describes the type of data this is
class(x)
###this tells you the dimensions of your object
dim(x)

```
After reading our data, we organize it the way we want it.
``` {r organize_data, include=TRUE}
###there is a data frame called samples in this and it stores group, library size, and normalization factor information
x$samples
##I decided to use my own gene information that I have from cuffnorm output
geneattr <- read.table("/Users/hollymcqueary/Dropbox/McQueary/Dosage-Compensation/Redo/September_2017/genes.attr_table.csv")
geneattrnames <- c("tracking_id","class_code","nearest_ref_id","gene_id","gene_short_name","tss_id","locus","length")
colnames(geneattr) <- geneattrnames
geneattrnames
View(geneattr)
##make a file with only the things that you want in it (in my case, I just want gene id and locus)
genenames <- select(geneattr,columns=c("gene_short_name","locus","length"))
##eliminate duplicates
x$genes <- genenames
x
genecolnames <- c("gene_id","locus","length")
##make a vector of gene lengths
gene.lengths <- as.numeric(x$genes$length)
gene.lengths
x
samplenames <- c("X112_0","X112_1","X112_2","X115_0","X115_1","X115_2","X117_0","X117_1","X117_2","X11_0","X11_1","X11_2","X123_0","X123_1","X123_2","X141_0","X141_1","X141_2","X152_0","X152_1","X152_2","X18_0","X18_1","X18_2","X1_0","X1_1","X1_2","X21_0","X21_1","X21_2","X29_0","X29_1","X29_2","X2_0","X2_1","X2_2","X31_0","X31_1","X31_2","X3_0","X3_1","X3_2","X49_0","X49_1","X49_2","X4_0","X4_1","X4_2","X50_0","X50_1","X50_2","X59_0","X59_1","X59_2","X5_0","X5_1","X5_2","X61_0","X61_1","X61_2","X66_0","X66_1","X66_2","X69_0","X69_1","X69_2","X6_0","X6_1","X6_2","X76_0","X76_1","X76_2","X77_0","X77_1","X77_2","X7_0","X7_1","X7_2","X8_0","X8_1","X8_2","X9_0","X9_1","X9_2","GCA_0","GCA_1","GCA_2","MAA_0","MAA_1","MAA_2")
```

Next, we move on to filtering the data.
We are filtering with count-per-million (CPM) rather than counts directly, since counts directly doesn't account for differences in library sizes. (from edgeR Users Guide)
``` {r filtering, include= TRUE}
cpm <- cpm(x)
lcpm <- cpm(x,log=TRUE)
table(rowSums(x$counts==0)==90)
#genes must be expressed in at least one group (group size 3-biological replicates) to be kept for downstream analysis
keep <- rowSums(cpm(x)>1) >= 3

#filters out lowly expressed genes
x.fil <- x[keep, , keep.lib.sizes=FALSE]
dim(x.fil)
#recalculate the library sizes after filtering
x.fil <- DGEList(counts=x.fil, group=group)
x.fil$samples
```

``` {r raw_vs_filtered, include=TRUE}
nsamples <- ncol(x.fil)
col <- brewer.pal(nsamples,"Paired")
par(mfrow=c(1,2))
plot(density(lcpm[,1]), col=col[1],lwd=2,ylim=c(0,0.3),las=2,main="",xlab="")
title(main="A. Raw data",xlab="Log-cpm")
abline(v=0,lty=3)
for (i in 2:nsamples){
  den <- density(lcpm[,i])
  lines(den$x,den$y,col=col[i],lwd=2)
}
legend("topright",samplenames,text.col=col, bty="n",cex=0.3,pt.cex=1,ncol=3)
lcpm.fil <- cpm(x.fil,log=TRUE)
plot(density(lcpm.fil[,1]), col=col[1],lwd=2,ylim=c(0,0.3),las=2,main="",xlab="")
title(main="B. Filtered data",xlab="Log-cpm")
abline(v=0,lty=3)
for (i in 2:nsamples){
  den <- density(lcpm.fil[,i])
  lines(den$x,den$y,col=col[i],lwd=2)
}
legend("topright",samplenames,text.col=col, bty="n",cex=0.3,pt.cex=1,ncol=3)
```


Next we move onto normalization of our data
Here I'm trying out all of the different normalization methods
Still looks like TMM is the best option for me. 
``` {r normalization, include=TRUE}
x.norm.TMM <- calcNormFactors(x.fil, method="TMM")
x.norm.RLE <- calcNormFactors(x.fil, method="RLE")
x.norm.UQ <- calcNormFactors(x.fil, method="upperquartile")
#can look at magnitude of scaling factors
x.norm.TMM$samples$norm.factors
x.norm.RLE$samples$norm.factors
x.norm.UQ$samples$norm.factors
#visualize the effects of normalization
par(mfrow=c(1,2))
lcpm <- cpm(x.fil,log=TRUE)
boxplot(lcpm,las=2,col=col,main="",cex=.2,cex.axis=.4)
title(main="A.Example: unnormalized data", ylab="Log-cpm")

lcpm.norm.TMM <- cpm(x.norm.TMM,log=TRUE)
boxplot(lcpm.norm.TMM,las=2,col=col,main="",cex=.2,cex.axis=.4)
title(main="B. Example: Normalized data-TMM", ylab="Log-cpm")

lcpm.norm.RLE <- cpm(x.norm.RLE,log=TRUE)
boxplot(lcpm.norm.RLE,las=2,col=col,main="",cex=.2,cex.axis=.4)
title(main="C. Example: Normalized data-RLE", ylab="Log-cpm")

lcpm.norm.UQ <- cpm(x.norm.UQ,log=TRUE)
boxplot(lcpm.norm.UQ,las=2,col=col,main="",cex=.2,cex.axis=.4)
title(main="C. Example: Normalized data-UQ", ylab="Log-cpm")
```

Multidimensional scaling plots can be used with limma. These plots show similarities between samples in an unsupervised manner so that you can determine how much differential expression can be found before you start testing things. (Law, et al 2016 F1000Research).
I used the plotMDS function below to make such a plot for my normalized data. First, I calculated the log-counts per million and then I plotted them. The first dimension will always explain most of the variation in the data (in my case, that was sample group). I then tried experimental groups (GC vs MA) and found that that explained a little of the variance too. Next time I could try clustering them by aneuploid and not aneuploid and see what happens (I would expect to see a greater difference between those than most of the other groups).

```{r MDS plots, include=TRUE}
lcpm <- cpm(x.norm,log=TRUE)
class(x.norm)
par(mfrow=c(1,2))
col.group <- group
levels(col.group) <- palette(rainbow(nlevels(col.group)))
col.group <- as.character(col.group)
plotMDS(lcpm,labels=group,col=col.group,main="A.Sample groups",cex=0.5)
col.exp <- exp
levels(col.exp) <- brewer.pal(2, "PuRd")
col.exp <- as.character(col.exp)
plotMDS(lcpm,labels=exp,col=col.exp,dim=c(3,4),main="B. Experiment",cex=0.5)
#also can make MDS plots
glMDSPlot(lcpm,labels=paste(group,exp,sep="_"),groups=x$samples[,c(2)],launch=FALSE)
```

Here, I made a design matrix and also a contrasts matrix
``` {r make_contrasts, include=TRUE}
design <- model.matrix(~0+group+exp)
colnames(design) <- gsub("group","",colnames(design))
design
contr.matrix <- makeContrasts(
  X1vsGCA = X1-GCA,
  X11vsGCA = X11-GCA,
  X112vsMAnc = X112-MAA,
  X115vsMAnc = X115-MAA,
  X117vsMAnc = X117-MAA,
  X123vsMAnc = X123-MAA,
  X141vsMAnc= X141-MAA,
  X152vsMAnc = X152-MAA,
  X18vsGCA = X18-GCA,
  X2vsGCA = X2-GCA,
  X21vsGCA = X21-GCA,
  X29vsMAnc = X29-MAA,
  X3vsGCA = X3-GCA,
  X31vsGCA = X31-GCA,
  X4vsGCA = X4-GCA,
  X49vsGCA = X49-GCA,
  X5vsGCA = X5-GCA,
  X50vsMAnc = X50-MAA,
  X59vsGCA = X59-GCA,
  X6vsGCA = X6-GCA,
  X61vsGCA = X61-GCA,
  X66vsGCA = X66-GCA,
  X69vsGCA = X69-GCA,
  X7vsGCA = X7-GCA,
  X76vsGCA = X76-GCA,
  X77vsGCA = X77-GCA,
  X8vsGCA = X8-GCA,
  X9vsGCA = X9-GCA,
  levels=colnames(design)
)

```

This one shows almost no DE genes for most of the samples

```{r quasi-likelihood F-tests, include=TRUE}
x <- read.delim("fileofcounts.txt",row.names="Symbol")
group <- factor(c(1,1,2,2))
y <- DGEList(counts=x,group=group)
y <- calcNormFactors(y)
design <- model.matrix(~group)
y <- estimateDisp(y,design)
fit <- glmQLFit(y,design)
qlf <- glmQLFTest(fit,coef=2)
topTags(qlf)
```

## edgeR notes from the documentation
I will put in code blocks of certain things you can do in edgeR and I can rearrange it later

```{r likelihood ratio tests, include=TRUE}
fit <- glmFit(y,design)
lrt <- glmLRT(fit,coef=2)
topTags(lrt)
```


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## R Markdown

This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:

```{r cars}
summary(cars)
```

## Including Plots

You can also embed plots, for example:

```{r pressure, echo=FALSE}
plot(pressure)
```

Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.
